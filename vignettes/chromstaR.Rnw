%\VignetteIndexEntry{The chromstaR users guide}
%\VignetteEngine{knitr::knitr}
\documentclass[11pt]{article}
\usepackage{hyperref}
\usepackage{url}
\usepackage[authoryear,round]{natbib}
\bibliographystyle{plainnat}

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}

\author{Aaron Taudt\footnote{aaron.taudt@gmail.com}}
\begin{document}
\title{The chromstaR user's guide}

\maketitle

\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

ChIP-seq has become the standard technique for assessing the genome-wide chromatin state of DNA. \Rpackage{chromstaR} provides functions for the joint analysis of multiple ChIP-seq samples. It allows peak calling for transcription factor binding and histone modifications with a narrow (e.g. H3K4me3, H3K27ac,~...) or broad (e.g. H3K36me3, H3K27me3,~...) profile. All analysis can be performed on each sample individually (=univariate), or in a joint analysis considering all samples simultaneously (=multivariate).

<<annotate,echo=FALSE>>=
options(fig.width=120)
@

\section{Outline of workflow}

Every analysis with the \Rpackage{chromstaR} package starts from aligned reads in either BAM or BED format. In the first step, the genome is partitioned into non-overlapping, equally sized bins and the reads that fall into each bin are counted. These read counts serve as the basis for both the univariate and the multivariate peak- and broad-region calling. Univariate peak calling is done by fitting a three-state Hidden Markov Model to the binned read counts. Multivariate peak calling for $\mathcal{S}$ samples is done by fitting a $2^\mathcal{S}$-state Hidden Markov Model to all binned read counts.

%' \section{Univariate analysis}
%' 
%' \subsection{\label{sec:narrow}Task 1: Peak calling for a narrow histone modification}
%' 
%' Examples of histone modifications with a narrow profile are H3K4me3, H3K9ac and H3K27ac in most human tissues. For such peak-like modifications, the bin size should be set to a value between 200bp and 1000bp.
%' 
%' \begin{scriptsize}
%' <<univariate_narrow_library, results='hide', message=FALSE, eval=TRUE>>=
%' library(chromstaR)
%' @
%' 
%' <<univariate_narrow_binning, results='show', message=FALSE, eval=TRUE>>=
%' ## === Step 1: Binning ===
%' # Get an example BED file
%' bedfile <- system.file("extdata","euratrans","liver-H3K4me3-BN-male-bio2-tech1.bed.gz",
%'                         package="chromstaRData")
%' # Get the chromosome lengths (see ?GenomeInfoDb::fetchExtendedChromInfoFromUCSC)
%' # This is only necessary for BED files. BAM files are handled automatically.
%' chrom.lengths <- data(rn4_chrominfo)
%' # We use bin size 1000bp and chromosome 12 to keep the example quick
%' binned.data <- binReads(bedfile, format='bed',assembly=rn4_chrominfo, binsizes=1000,
%'                         chromosomes='chr12')
%' print(binned.data)
%' @
%' 
%' <<univariate_narrow_peak_calling, results='markup', eval=TRUE>>=
%' ## === Step 2: Peak calling ===
%' # We restrict the peak calling to 60 seconds to keep this example quick.
%' model <- callPeaksUnivariate(binned.data, ID='H3K4me3', max.time=60, verbosity=0)
%' @
%' 
%' <<univariate_narrow_plotting, fig.width=6, fig.height=4>>=
%' ## === Step 3: Checking the fit ===
%' # For a narrow modification, the fit should look something like this,
%' # with the 'modified'-component near the bottom of the figure
%' plot(model)
%' @
%' 
%' <<univariate_narrow_export, results='hide', message=FALSE, eval=FALSE>>=
%' ## === Step 4: Export to genome browser ===
%' # We can export peak calls and binned read counts with
%' exportUnivariates(list(model), filename='your-peak-file', what='peaks')
%' exportUnivariates(list(model), filename='your-read-file', what='counts')
%' @
%' \end{scriptsize}
%' 
%' \subsection{\label{sec:broad}Task 2: Peak calling for a broad histone modification}
%' 
%' Examples of histone modifications with a broad profile are H3K9me3, H3K27me3, H3K36me3, H4K20me1 in most human tissues. These modifications usually cover broad domains of the genome, and the enrichment is best captured with a bin size between 500bp and 2000bp.
%' 
%' \begin{scriptsize}
%' <<univariate_broad_library, results='hide', message=FALSE, eval=TRUE>>=
%' library(chromstaR)
%' @
%' 
%' <<univariate_broad_binning, results='hide', message=FALSE, eval=TRUE>>=
%' ## === Step 1: Binning ===
%' # Get an example BED file
%' bedfile <- system.file("extdata","euratrans","liver-H3K27me3-BN-male-bio1-tech1.bed.gz",
%'                         package="chromstaRData")
%' # Get the chromosome lengths (see ?GenomeInfoDb::fetchExtendedChromInfoFromUCSC)
%' # This is only necessary for BED files. BAM files are handled automatically.
%' chrom.lengths <- data(rn4_chrominfo)
%' # We use bin size 1000bp and chromosome 12 to keep the example quick
%' binned.data <- binReads(bedfile, format='bed',assembly=rn4_chrominfo, binsizes=1000,
%'                         chromosomes='chr12')
%' print(binned.data)
%' @
%' 
%' <<univariate_broad_peak_calling, results='markup', eval=TRUE>>=
%' ## === Step 2: Peak calling ===
%' # We restrict the peak calling to 60 seconds to keep this example quick.
%' model <- callPeaksUnivariate(binned.data, ID='H3K27me3', max.time=60, verbosity=0)
%' @
%' 
%' <<univariate_broad_plotting, fig.width=6, fig.height=4>>=
%' ## === Step 3: Checking the fit ===
%' # For a broad modification, the fit should look something like this,
%' # with a 'modified'-component that fits the thick tail of the distribution.
%' plot(model)
%' @
%' 
%' <<univariate_broad_export, results='hide', message=FALSE, eval=FALSE>>=
%' ## === Step 4: Export to genome browser ===
%' # We can export peak calls and binned read counts with
%' exportUnivariates(list(model), filename='your-peak-file', what='peaks')
%' exportUnivariates(list(model), filename='your-read-file', what='counts')
%' @
%' 
%' <<univariate_broad_H4K20me1, echo=TRUE, results='hide', message=FALSE, fig.width=6, fig.height=4>>=
%' ## === Step 1-3: Another example for mark H4K20me1 ===
%' bedfile <- system.file("extdata","euratrans","liver-H4K20me1-BN-male-bio1-tech1.bed.gz",
%'                        package="chromstaRData")
%' data(rn4_chrominfo)
%' binned.data <- binReads(bedfile, format='bed',assembly=rn4_chrominfo, binsizes=1000,
%'                         chromosomes='chr12')
%' model <- callPeaksUnivariate(binned.data, ID='H4K20me1', max.time=60, verbosity=0)
%' plot(model)
%' @
%' 
%' \end{scriptsize}
%' 
%' \subsection{Task 3: Peak calling for ATAC-seq, DNase-seq, FAIRE-seq, ...}
%' 
%' Peak calling for ATAC-seq and DNase-seq is similar to the peak calling of a narrow histone modification (see section~\ref{sec:narrow}). FAIRE-seq experiments seem to exhibit a broad profile with our model, so the procedure is similar to the domain calling of a broad histone modification (see section~\ref{sec:broad}).
%' 
%' \section{Multivariate analysis}
%' \subsection{Task 1: Integrating multiple replicates}
%' 
%' \Rpackage{chromstaR} can be used to call peaks with multiple replicates, without the need of prior merging. The underlying statistical model integrates information from all replicates to identify common peaks. It is, however, important to note that replicates with poor quality can affect the joint peak calling negatively. It is therefore recommended to first check the replicate quality and discard poor-quality replicates. The necessary steps for peak calling for an example ChIP-seq experiment with 4 replicates are detailed below.
%' 
%' \begin{scriptsize}
%' <<univariate_replicate_library, results='hide', message=FALSE, eval=TRUE>>=
%' library(chromstaR)
%' @
%' 
%' <<multivariate_replicate_binning, results='show', message=FALSE, eval=TRUE>>=
%' ## === Step 1: Binning ===
%' # Let's get some example data with 3 replicates
%' file.path <- system.file("extdata","euratrans", package='chromstaRData')
%' bedfiles.good <- list.files(file.path, pattern="liver.*H3K27me3", full.names=TRUE)[1:3]
%' # We fake a replicate with poor quality by taking a different mark entirely
%' bedfiles.poor <- list.files(file.path, pattern="liver.*H4K20me1", full.names=TRUE)[1]
%' bedfiles <- c(bedfiles.good, bedfiles.poor)
%' # This is only necessary for BED files. BAM files are handled automatically.
%' data(rn4_chrominfo)
%' # We use bin size 1000bp and chromosome 12 to keep the example quick
%' binned.data <- list()
%' for (bedfile in bedfiles) {
%'   binned.data[[basename(bedfile)]] <- binReads(bedfile, format='bed', binsize=1000,
%'                                          assembly=rn4_chrominfo, chromosomes='chr12')
%' }
%' @
%' 
%' <<multivariate_replicate_univariate, results='hide', message=FALSE, eval=TRUE>>=
%' ## === Step 2: Univariate peak calling ===
%' # The univariate fit is obtained for each replicate
%' models <- list()
%' for (i1 in 1:length(binned.data)) {
%'   models[[i1]] <- callPeaksUnivariate(binned.data[[i1]], ID=paste0('Rep',i1),
%'                                       max.time=60)
%' }
%' @
%' 
%' <<multivariate_replicate_peak_calling, results='show', message=FALSE, eval=TRUE>>=
%' ## === Step 3: Check replicate correlation ===
%' # We run a multivariate peak calling on all 4 replicates
%' # A warning is issued because replicate 4 is very different from the others
%' multi.model <- callPeaksReplicates(models, max.time=60, eps=1)
%' # Checking the correlation confirms that Rep4 is very different from the others
%' print(multi.model$replicateInfo$correlation)
%' @
%' 
%' <<multivariate_replicate_peak_calling2, results='hide', message=FALSE, eval=TRUE>>=
%' ## === Step 4: Peak calling with replicates ===
%' # We redo the previous step without the "bad" replicate
%' # Also, we force all replicates to agree in their peak calls
%' multi.model <- callPeaksReplicates(models[1:3], force.equal=TRUE, max.time=60)
%' @
%' 
%' <<multivariate_replicate_export, results='hide', message=FALSE, eval=FALSE>>=
%' ## === Step 5: Export to genome browser ===
%' # Finally, we can export the results as BED file
%' exportMultivariate(multi.model, filename='your-peak-file', what='peaks')
%' exportMultivariate(multi.model, filename='your-read-file', what='counts')
%' @
%' \end{scriptsize}
%' 
%' \subsection{Task 2: Detecting differentially modified regions}
%' 
%' \Rpackage{chromstaR} is extremely powerful in detecting differentially modified regions in two or more samples. The following example illustrates this on ChIP-seq data for H4K20me1 in liver and heart (left-ventricle) tissues from rat. With 2 samples we can have $2^2 = 4$ combinatorial states, which can be readily interpreted as '0: all samples unmodified', '1-2: DMR' and '3: all samples modified'. Having several replicates for each sample makes it more complicated, but you get the idea ...
%' 
%' \begin{scriptsize}
%' <<univariate_differential_library, results='hide', message=FALSE, eval=TRUE>>=
%' library(chromstaR)
%' @
%' 
%' <<multivariate_differential_binning, results='hide', message=FALSE, eval=TRUE>>=
%' ## === Step 1: Binning ===
%' # Let's get some example data for heart (lv) and liver with 3 replicates each
%' file.path <- system.file("extdata","euratrans", package='chromstaRData')
%' bedfiles <- list.files(file.path, pattern="H4K20me1", full.names=TRUE)
%' # This is only necessary for BED files. BAM files are handled automatically.
%' data(rn4_chrominfo)
%' # We use bin size 1000bp and chromosome 12 to keep the example quick
%' binned.data <- list()
%' for (bedfile in bedfiles) {
%'   binned.data[[basename(bedfile)]] <- binReads(bedfile, format='bed', binsize=1000,
%'                                          assembly=rn4_chrominfo, chromosomes='chr12')
%' }
%' @
%' 
%' <<multivariate_differential_univariate, results='hide', message=FALSE, eval=TRUE>>=
%' ## === Step 2: Univariate peak calling ===
%' # The univariate fit is obtained for each replicate
%' models <- list()
%' for (i1 in 1:length(binned.data)) {
%'   models[[i1]] <- callPeaksUnivariate(binned.data[[i1]], ID=names(binned.data)[i1],
%'                                       max.time=60)
%' }
%' @
%' 
%' <<multivariate_differential_stateBrewer, results='markup', message=TRUE, eval=TRUE>>=
%' ## === Step 3: Constructing the combinatorial states ===
%' # This step is only necessary if you have replicates for each sample.
%' # To ensure that replicates are treated as such, and not as independent
%' # samples, we have to construct the proper combinatorial states:
%' 
%' # First, we get all the tissues (we could specify them by hand, but we are lazy)
%' IDs <- names(binned.data)
%' tissues <- sapply(strsplit(IDs,'-'),'[[',1)
%' marks <- sapply(strsplit(IDs,'-'),'[[',2)
%' print(tissues)
%' # Second, we obtain the combinatorial states
%' # Look up ?stateBrewer on how to use this function
%' states <- stateBrewer(tissues)
%' print(states)
%' # Third, we construct differential states
%' diff.states <- stateBrewer(tissues, differential.states=TRUE, conditions=tissues,
%'                            tracks2compare=marks)
%' print(diff.states)
%' @
%' 
%' <<multivariate_differential_multivariate, results='hide', message=FALSE, eval=TRUE>>=
%' ## === Step 4: Multivariate peak calling ===
%' multi.model <- callPeaksMultivariate(models, use.states=states, eps=1, max.time=60)
%' @
%' 
%' <<multivariate_differential_export, results='hide', message=FALSE, eval=FALSE>>=
%' ## === Step 5: Export to genome browser ===
%' # Export only differential peaks by excluding the 'common.states'
%' exportMultivariate(multi.model, filename='your-peak-file', what='peaks',
%'                    include.states=diff.states)
%' exportMultivariate(multi.model, filename='your-read-file', what='counts',
%'                    include.states=diff.states)
%' exportMultivariate(multi.model, filename='your-combstates-file', what='combstates',
%'                    include.states=diff.states)
%' @
%' \end{scriptsize}

\subsection{Task 3: Finding combinatorial chromatin states}

Most experimental studies that probe several histone modifications are interested in combinatorial chromatin states. An example of a simple combinatorial state would be [H3K4me3+H3K27me3], which is also frequently called ``bivalent promoter'', due to the simultaneous occurrence of the promoter marking H3K4me3 and the repressive H3K27me3. Finding combinatorial states with \Rpackage{chromstaR} is equivalent to a multivariate peak calling. The following code chunks demonstrate how to find bivalent promoters and do some simple analysis:

\begin{scriptsize}
<<univariate_combinatorial_library, results='hide', message=FALSE, eval=TRUE>>=
library(chromstaR)
@

<<multivariate_combinatorial_binning, results='hide', message=FALSE, eval=TRUE>>=
## === Step 1: Binning ===
# Let's get some example data for H3K27me3 and H3K4me3 in rat liver
file.path <- system.file("extdata","euratrans", package='chromstaRData')
bedfiles <- list.files(file.path, pattern="liver.*H3K4me3|liver.*H3K27me3",
                       full.names=TRUE)
# This is only necessary for BED files. BAM files are handled automatically.
data(rn4_chrominfo)
# We use bin size 1000bp and chromosome 12 to keep the example quick
binned.data <- list()
for (bedfile in bedfiles) {
  binned.data[[basename(bedfile)]] <- binReads(bedfile, format='bed', binsize=1000,
                                         assembly=rn4_chrominfo, chromosomes='chr12')
}
@

<<multivariate_combinatorial_univariate, results='hide', message=FALSE, eval=TRUE>>=
## === Step 2: Univariate peak calling ===
# The univariate fit is obtained for each replicate
models <- list()
for (i1 in 1:length(binned.data)) {
  models[[i1]] <- callPeaksUnivariate(binned.data[[i1]], ID=names(binned.data)[i1],
                                      max.time=60)
}
@

<<multivariate_combinatorial_stateBrewer, results='show', message=TRUE, eval=TRUE>>=
## === Step 3: Constructing the combinatorial states ===
# This step is only necessary if you have replicates for each sample.
# To ensure that replicates are treated as such, and not as independent
# samples, we have to construct the proper combinatorial states:

# First, we get all the marks (we could specify them by hand, but we are lazy)
IDs <- names(binned.data)
marks <- sapply(strsplit(IDs,'-'),'[[',2)
print(marks)
# Second, we obtain the combinatorial states
# Look up ?stateBrewer on how to use this function
states <- stateBrewer(marks)
print(states)
@

<<multivariate_combinatorial_multivariate, results='show', message=FALSE, eval=TRUE>>=
## === Step 4: Multivariate peak calling ===
multi.model <- callPeaksMultivariate(models, use.states=states, eps=1, max.time=60)
@

<<multivariate_combinatorial_export, results='hide', message=FALSE, eval=FALSE>>=
## === Step 5: Export to genome browser ===
# Export combinatorial states
exportMultivariate(multi.model, filename='your-file', what=c('peaks','counts'))
exportMultivariate(multi.model, filename='your-combstates', what=c('combstates'))
@

<<multivariate_combinatorial_analysis, results='show', message=FALSE, eval=TRUE>>=
## === Step 6: Enrichment analysis ===
# Get coordinates of rat genes
library(biomaRt)
ensembl <- useMart('ENSEMBL_MART_ENSEMBL', host='may2012.archive.ensembl.org',
                    dataset='rnorvegicus_gene_ensembl')
genes <- getBM(attributes=c('ensembl_gene_id', 'chromosome_name', 'start_position',
                            'end_position', 'strand', 'external_gene_id'),
               mart=ensembl)
# Transform to GRanges for easier handling
genes <- GRanges(seqnames=paste0('chr',genes$chrom),
                 ranges=IRanges(start=genes$start, end=genes$end),
                 strand=genes$strand,
                 name=genes$external_gene_id)
print(genes)

# Calculate enrichment
enrich <- enrichmentCurve(multi.model, genes)

@

\end{scriptsize}

\section{\label{sec:faq}FAQ}

\section{Session Info}
\begin{scriptsize}
<<>>=
sessionInfo()
warnings()
@
\end{scriptsize}

\end{document}

