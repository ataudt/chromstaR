#' Fit a Hidden Markov Model to multiple ChIP-seq samples.
#'
#' Fit a HMM to multiple ChIP-seq samples to determine the combinatorial state of genomic regions. Input is a list of \code{\link{chromstaR_univariateHMM}}s generated by \code{\link{callPeaksUnivariate}}.
#'
#' Emission distributions from the univariate HMMs are used with a Gaussian copula to generate a multivariate emission distribution for each combinatorial state. This multivariate distribution is then kept fixed and the transition probabilities are fitted with a Baum-Welch. See our paper TODO:insert paper for details.
#'
#' @author Aaron Taudt, Maria Colome Tatche
#' @param modellist A list of \code{\link{chromstaR_univariateHMM}}s generated by \code{\link{callPeaksUnivariate}}, e.g. \code{list(hmm1,hmm2,...)} or \code{c("file1","file2",...)}.
#' @param use.states A vector of combinatorial states which are used in the multivariate HMM. If specified, option \code{num.states} will be ignored. An error is thrown if the specified states cannot be used (either because they do not exist or their occurrence in the genome is too low).
#' @param num.states Number of combinatorial states to use in the multivariate HMM. The states are ordered by occurrence as determined from the combination of univariate state calls. If it is not possible to use the specified number of states - e.g. because the total number of combinatorial states is lower or because the inverse of the correlation matrix would be singular for some states - a warning is issued and the maximum possible number of states is used instead.
#' @param eps Convergence threshold for the Baum-Welch algorithm.
#' @param FDR False discovery rate. code{NULL} means that the state with maximum posterior probability will be chosen, irrespective of its absolute probability.
#' @param keep.posteriors If set to \code{TRUE}, posteriors will be available in the output. This is useful to change the FDR later, but increases the necessary disk space to store the result immense.
#' @param num.threads Number of threads to use. Setting this to >1 may give increased performance.
#' @param max.time The maximum running time in seconds for the Baum-Welch algorithm. If this time is reached, the Baum-Welch will terminate after the current iteration finishes. The default -1 is no limit.
#' @param max.iter The maximum number of iterations for the Baum-Welch algorithm. The default -1 is no limit.
#' @param checkpoint.after.iter Write a checkpoint file every n iterations. The default -1 means no checkpointing for iterations.
#' @param checkpoint.after.time Write a checkpoint file every t seconds. The default -1 means no checkpointing for time.
#' @param checkpoint.file The name of the checkpoint file that will be written.
#' @param checkpoint.overwrite If set to \code{TRUE}, only one checkpoint file will be written. If set to \code{FALSE}, a new checkpoint file will be written at each checkpoint with the total number of iterations appended.
#' @param checkpoint.use.existing If set to \code{TRUE}, the Baum-Welch fitting procedure will be continued from the HMM in the \code{checkpoint.file}.
#' @param A.initial A transition matrix to start the Baum-Welch from.
#' @param keep.densities If set to \code{TRUE} (default=\code{FALSE}), densities will be available in the output. This should only be needed debugging.
#' @param verbosity Verbosity level for the fitting procedure. 0 - No output, 1 - Iterations are printed.
#' @return Output is a \code{\link{chromstaR_multivariateHMM}} list object.
#' @seealso \code{\link{chromstaR_multivariateHMM}}, \code{\link{callPeaksUnivariate}}
#' @examples
#'## Get example BED-files with ChIP-seq reads for H3K36me3
#' # in 7 different brain tissues (chr22)
#'path.to.example <- system.file(file.path("extdata","brain"), package="chromstaR")
#'bedfiles <- list.files(path.to.example, full=TRUE)
#'## Bin the data into bin size 1000bp and build the univariate HMM
#'uni.HMMs <- list()
#'for (bedfile in bedfiles) {
#'  binned.data <- bed2binned(bedfile, assembly='hg19', binsize=1000,
#'                            save.as.RData=FALSE)
#'  uni.HMMs[[bedfile]] <- callPeaksUnivariate(binned.data, ID=basename(bedfile),
#'                                             max.time=30, eps=0.01)
#'}
#'## Build the multivariate Hidden Markov Model from the list of univariate fits
#'multi.hmm <- callPeaksMultivariate(uni.HMMs, eps=0.1, max.time=300)
#' @export
callPeaksMultivariate <- function(modellist, use.states=NULL, num.states=NULL, eps=0.001, FDR=NULL, keep.posteriors=FALSE, num.threads=1, max.time=-1, max.iter=-1, checkpoint.after.iter=-1, checkpoint.after.time=-1, checkpoint.file=NULL, checkpoint.overwrite=TRUE, checkpoint.use.existing=FALSE, A.initial=NULL, keep.densities=FALSE, verbosity=1) {

	## Intercept user input
	if (check.univariate.modellist(modellist)!=0) {
		message("Loading univariate HMMs from files ...", appendLF=F)
		ptm <- proc.time()
		mlist <- NULL
		for (modelfile in modellist) {
			mlist[[length(mlist)+1]] <- get(load(modelfile))
		}
		modellist <- mlist
		remove(mlist)
		time <- proc.time() - ptm
		message(" ",round(time[3],2),"s")
		if (check.univariate.modellist(modellist)!=0) stop("argument 'modellist' expects a list of univariate hmms or a list of files that contain univariate hmms")
	}
	if (!is.null(use.states)) {
		if (check.nonnegative.integer.vector(use.states)!=0) stop("argument 'comb.states' expects a vector of positive integers")
		num.states <- NULL
	}
	if (!is.null(num.states)) {
		if (check.positive.integer(num.states)!=0) stop("argument 'num.states' expects a positive integer")
	}
	if (check.positive(eps)!=0) stop("argument 'eps' expects a positive numeric")
	if (check.positive.integer(num.threads)!=0) stop("argument 'num.threads' expects a positive integer")
	if (check.integer(max.time)!=0) stop("argument 'max.time' expects an integer")
	if (check.integer(max.iter)!=0) stop("argument 'max.iter' expects an integer")
	if (check.integer(checkpoint.after.iter)!=0) stop("argument 'checkpoint.after.iter' expects an integer")
	if (check.integer(checkpoint.after.time)!=0) stop("argument 'checkpoint.after.time' expects an integer")
	if (check.logical(checkpoint.overwrite)!=0) stop("argument 'checkpoint.overwrite' expects a logical (TRUE or FALSE)")
	if (check.logical(keep.posteriors)!=0) stop("argument 'keep.posteriors' expects a logical (TRUE or FALSE)")
	if (check.logical(keep.densities)!=0) stop("argument 'keep.densities' expects a logical (TRUE or FALSE)")
	if (check.integer(verbosity)!=0) stop("argument 'verbosity' expects an integer")
	if (!is.null(FDR)) {
		if (FDR>1 | FDR<0) stop("argument 'FDR' has to be between 0 and 1 if specified")
	}
	get.posteriors <- TRUE

	## Prepare the HMM
	params <- prepare.multivariate(modellist, use.states=use.states, num.states=num.states, num.threads=num.threads)
	bins <- params$bins
	reads <- params$reads
	numbins <- params$numbins
	nummod <- params$nummod
	comb.states2use <- params$comb.states
	comb.states.per.bin <- params$comb.states.per.bin
	distributions <- params$distributions
	weights <- params$weights
	correlationMatrix2use <- params$correlationMatrix
	correlationMatrixInverse2use <- params$correlationMatrixInverse
	determinant2use <- params$determinant
	usestateTF <- params$usestateTF
	numstates2use <- params$numstates2use
	IDs <- params$IDs
	# Clean up to reduce memory usage
	remove(modellist)
	remove(params)

	### Define cleanup behaviour ###
	on.exit(.C("R_multivariate_cleanup", as.integer(nummod)))

	## Starting multivariate HMM
	message("\nStarting multivariate HMM")
	message("Using the following combinatorial states, covering ", mean(comb.states.per.bin %in% comb.states2use)*100, "% of the bins:\n", paste(comb.states2use, collapse=" "),"\n", appendLF=F)

	# Prepare input for C function
	rs <- unlist(lapply(distributions,"[",2:3,'size'))
	ps <- unlist(lapply(distributions,"[",2:3,'prob'))
	ws1 <- unlist(lapply(weights,"[",1))
	ws2 <- unlist(lapply(weights,"[",2))
	ws3 <- unlist(lapply(weights,"[",3))
	ws <- ws1 / (ws2+ws1)
	if (get.posteriors) { lenPosteriors <- numbins * numstates2use } else { lenPosteriors <- 1 }
	if (keep.densities) { lenDensities <- numbins * numstates2use } else { lenDensities <- 1 }

	# Load checkpoint file if it exists and if desired
	if (is.null(checkpoint.file)) {
		checkpoint.file.exists <- FALSE
	} else {
		if (file.exists(checkpoint.file)) {
			checkpoint.file.exists <- TRUE
		} else {
			checkpoint.file.exists <- FALSE
		}
	}
	if (checkpoint.file.exists & checkpoint.use.existing) {
		message("Loading checkpoint file ",checkpoint.file)
		hmm <- get(load(checkpoint.file))
		A.initial <- hmm$transitionProbs
		proba.initial <- hmm$startProbs
		use.initial <- TRUE
	} else {
		if (is.null(A.initial)) {
			A.initial <- double(length=numstates2use*numstates2use)
			proba.initial <- double(length=numstates2use)
			use.initial <- FALSE
		} else {
			proba.initial <- rep(1/numstates2use, numstates2use)
			use.initial <- TRUE
		}
	}
	if (checkpoint.after.iter < 0) {
		checkpoint.after.iter <- max.iter
	}
	if (checkpoint.after.time < 0) {
		checkpoint.after.time <- max.time
	}
	iteration.total <- 0
	time.total <- 0
	repeat{
		# Determine runtime
		if (max.iter >= 0) {
			max.iter.temp <- min(checkpoint.after.iter, max.iter-iteration.total)
		} else {
			max.iter.temp <- checkpoint.after.iter
		}
		if (max.time > 0) {
			max.time.temp <- min(checkpoint.after.time, max.time-time.total)
		} else {
			max.time.temp <- checkpoint.after.time
		}
		# Call the C function
		hmm <- .C("R_multivariate_hmm",
			reads = as.integer(as.vector(reads)), # int* multiO
			num.bins = as.integer(numbins), # int* T
			num.states = as.integer(numstates2use), # int* N
			num.modifications = as.integer(nummod), # int* Nmod
			comb.states = as.integer(comb.states2use), # int* comb_states
			size = as.double(rs), # double* size
			prob = as.double(ps), # double* prob
			w = as.double(ws), # double* w
			correlation.matrix.inverse = as.double(correlationMatrixInverse2use), # double* cor_matrix_inv
			determinant = as.double(determinant2use), # double* det
			num.iterations = as.integer(max.iter.temp), # int* maxiter
			time.sec = as.integer(max.time.temp), # double* maxtime
			loglik.delta = as.double(eps), # double* eps
			posteriors = double(length=lenPosteriors), # double* posteriors
			get.posteriors = as.logical(get.posteriors), # bool* keep_posteriors
			densities = double(length=lenDensities), # double* densities
			keep.densities = as.logical(keep.densities), # bool* keep_densities
			states = integer(length=numbins), # int* states
			A = double(length=numstates2use*numstates2use), # double* A
			proba = double(length=numstates2use), # double* proba
			loglik = double(length=1), # double* loglik
			A.initial = as.double(A.initial), # double* initial A
			proba.initial = as.double(proba.initial), # double* initial proba
			use.initial.params = as.logical(use.initial), # bool* use_initial_params
			num.threads = as.integer(num.threads), # int* num_threads
			error = as.integer(0), # error handling
			verbosity = as.integer(verbosity) # int* verbosity
			)
			
		### Check convergence ###
		if (hmm$error == 1) {
			stop("A nan occurred during the Baum-Welch! Parameter estimation terminated prematurely. Check your read counts for very high numbers, they could be the cause for this problem.")
		} else if (hmm$error == 2) {
			stop("An error occurred during the Baum-Welch! Parameter estimation terminated prematurely.")
		}

		### Make return object ###
			result <- list()
			result$IDs <- IDs
		## Bin coordinates, posteriors and states
			result$bins <- bins
			result$bins$reads <- reads
			if (get.posteriors) {
				message("Transforming posteriors to `per sample` representation ...", appendLF=F); ptm <- proc.time()
				hmm$posteriors <- matrix(hmm$posteriors, ncol=hmm$num.states)
				colnames(hmm$posteriors) <- paste0("P(",hmm$comb.states,")")
				post.per.track <- matrix(0, ncol=hmm$num.modifications, nrow=hmm$num.bins)
				colnames(post.per.track) <- result$IDs
				binstates <- dec2bin(hmm$comb.states, ndigits=hmm$num.modifications)
				for (icol in 1:ncol(post.per.track)) {
					binstate.matrix <- matrix(rep(binstates[icol,], hmm$num.bins), nrow=hmm$num.bins, byrow=T)
					post.per.track <- post.per.track + binstate.matrix * hmm$posteriors[,icol]
				}
				result$bins$posteriors <- post.per.track
				time <- proc.time() - ptm; message(" ",round(time[3],2),"s")
			}
			message("Calculating states from posteriors ...", appendLF=F); ptm <- proc.time()
			if (!is.null(FDR)) {
				result$bins$state <- factor(bin2dec(result$bins$posteriors >= 1-FDR), levels=hmm$comb.states)
			} else {
				result$bins$state <- factor(hmm$states, levels=hmm$comb.states)
			}
			time <- proc.time() - ptm; message(" ",round(time[3],2),"s")
			if (keep.densities) {
				result$bins$densities <- matrix(hmm$densities, ncol=hmm$num.states)
			}
			
		## Segmentation
			message("Making segmentation ...", appendLF=F); ptm <- proc.time()
			df <- as.data.frame(result$bins)
			ind.readcols <- which(grepl('^reads', names(df)))
			ind.postcols <- which(grepl('^posteriors', names(df)))
			red.df <- suppressMessages(collapseBins(df, column2collapseBy='state', columns2average=c(ind.readcols, ind.postcols), columns2drop=c('width')))
			mean.reads <- matrix(unlist(red.df[,grepl('^mean.reads',names(red.df))]), ncol=length(result$IDs))
			colnames(mean.reads) <- colnames(result$IDs)
			mean.posteriors <- matrix(unlist(red.df[,grepl('^mean.posteriors',names(red.df))]), ncol=length(result$IDs))
			colnames(mean.posteriors) <- colnames(result$IDs)
			red.gr <- GRanges(seqnames=red.df[,1], ranges=IRanges(start=red.df[,2], end=red.df[,3]), strand=red.df[,4], state=red.df[,'state'])
			red.gr$mean.reads <- mean.reads
			red.gr$mean.posteriors <- mean.posteriors
			result$segments <- red.gr
			seqlengths(result$segments) <- seqlengths(result$bins)
			if (!keep.posteriors) {
				result$bins$posteriors <- NULL
			}
			time <- proc.time() - ptm; message(" ",round(time[3],2),"s")
		## Parameters
			# Weights
			tstates <- table(hmm$states)
			result$weights <- sort(tstates/sum(tstates), decreasing=T)
			result$weights.univariate <- weights
			# Transition matrices
			result$transitionProbs <- matrix(hmm$A, ncol=numstates2use, byrow=TRUE)
			colnames(result$transitionProbs) <- comb.states2use
			rownames(result$transitionProbs) <- comb.states2use
			result$transitionProbs.initial <- matrix(hmm$A.initial, ncol=numstates2use, byrow=TRUE)
			colnames(result$transitionProbs.initial) <- comb.states2use
			rownames(result$transitionProbs.initial) <- comb.states2use
			# Initial probs
			result$startProbs <- hmm$proba
			names(result$startProbs) <- paste0("P(",comb.states2use,")")
			result$startProbs.initial <- hmm$proba.initial
			names(result$startProbs.initial) <- paste0("P(",comb.states2use,")")
			# Distributions
			result$distributions <- distributions
			names(result$distributions) <- IDs
			# FDR
			result$FDR <- FDR
		## Convergence info
			convergenceInfo <- list(eps=eps, loglik=hmm$loglik, loglik.delta=hmm$loglik.delta, num.iterations=hmm$num.iterations, time.sec=hmm$time.sec)
			result$convergenceInfo <- convergenceInfo
		## Correlation matrices
			result$correlation.matrix <- correlationMatrix2use
		## Add class
			class(result) <- class.multivariate.hmm

		# Adjust parameters for the next round
		A.initial <- result$transitionProbs
		proba.initial <- hmm$proba
		use.initial <- TRUE
		iteration.total <- iteration.total + hmm$num.iterations
		result$convergenceInfo$num.iterations <- iteration.total
		time.total <- time.total + hmm$time.sec
		result$convergenceInfo$time.sec <- time.total
		# Test if terminating condition has been reached
		if (result$convergenceInfo$loglik.delta <= result$convergenceInfo$eps | (time.total >= max.time & max.time >= 0) | (iteration.total >= max.iter & max.iter >= 0)) break
		# Reduce the hmm for checkpointing
		result[c('bins','segments')] <- NULL
		# Save checkpoint
		hmm.checkpoint <- result
		if (checkpoint.overwrite) {
			message("Saving checkpoint to file ",checkpoint.file)
			save(hmm.checkpoint, file=checkpoint.file)
		} else {
			cfile <- paste(checkpoint.file,"_iteration_",iteration.total, sep="")
			message("Saving checkpoint to file ",cfile)
			save(hmm.checkpoint, file=cfile)
		}
		message("Total time: ", time.total)
		message("Total iterations: ", iteration.total)
		message("\nRestarting HMM")
	}
	
	## Check convergence
	if (result$convergenceInfo$loglik.delta > result$convergenceInfo$eps) {
		war <- warning("HMM did not converge!\n")
	}
	return(result)

}
