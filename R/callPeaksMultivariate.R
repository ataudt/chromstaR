#' Fit a Hidden Markov Model to multiple ChIP-seq samples
#'
#' Fit a HMM to multiple ChIP-seq samples to determine the combinatorial state of genomic regions. Input is a list of \code{\link{uniHMM}}s generated by \code{\link{callPeaksUnivariate}}.
#'
#' Emission distributions from the univariate HMMs are used with a Gaussian copula to generate a multivariate emission distribution for each combinatorial state. This multivariate distribution is then kept fixed and the transition probabilities are fitted with a Baum-Welch. See our paper TODO:insert paper for details.
#'
#' @author Aaron Taudt, Maria Colome Tatche
#' @param hmms A list of \code{\link{uniHMM}}s generated by \code{\link{callPeaksUnivariate}}, e.g. \code{list(hmm1,hmm2,...)} or \code{c("file1","file2",...)}.
#' @param use.states A data.frame with combinatorial states which are used in the multivariate HMM. This data.frame must be generated by the function \code{\link{state.brewer}}. If both \code{use.states} and \code{max.states} are \code{NULL}, the maximum possible number of combinatorial states will be used.
#' @param max.states Maximum number of combinatorial states to use in the multivariate HMM. The states are ordered by occurrence as determined from the combination of univariate state calls.
#' @param per.chrom If \code{per.chrom=TRUE} chromosomes will be treated separately. This tremendously speeds up the calculation but results might be noisier as compared to \code{per.chrom=FALSE}, where all chromosomes are concatenated for the HMM.
#' @param chromosomes A vector specifying the chromosomes to use from the models in \code{hmms}. The default (\code{NULL}) uses all available chromosomes.
#' @param eps Convergence threshold for the Baum-Welch algorithm.
#' @param post.cutoff False discovery rate. The default \code{NULL} means that the state with maximum posterior probability will be chosen, irrespective of its absolute probability.
#' @param keep.posteriors If set to \code{TRUE}, posteriors will be available in the output. This is useful to change the post.cutoff later, but increases the necessary disk space to store the result immense.
#' @param num.threads Number of threads to use. Setting this to >1 may give increased performance.
#' @param max.time The maximum running time in seconds for the Baum-Welch algorithm. If this time is reached, the Baum-Welch will terminate after the current iteration finishes. The default \code{NULL} is no limit.
#' @param max.iter The maximum number of iterations for the Baum-Welch algorithm. The default \code{NULL} is no limit.
#' @param keep.densities If set to \code{TRUE} (default=\code{FALSE}), densities will be available in the output. This should only be needed debugging.
#' @param verbosity Verbosity level for the fitting procedure. 0 - No output, 1 - Iterations are printed.
#' @return A \code{\link{multiHMM}} object.
#' @seealso \code{\link{multiHMM}}, \code{\link{callPeaksUnivariate}}, \code{\link{callPeaksReplicates}}
#' @import doParallel
#' @import foreach
#' @export
#' @examples
#'# Get example BED files for 2 different marks in hypertensive rat
#'file.path <- system.file("extdata","euratrans", package='chromstaRData')
#'bedfiles <- list.files(file.path, full.names=TRUE, pattern='SHR')[c(1:2,6:7)]
#'# Bin the data
#'data(rn4_chrominfo)
#'binned.data <- list()
#'for (bedfile in bedfiles) {
#'  binned.data[[basename(bedfile)]] <- binReads(bedfile, binsize=1000,
#'                                               assembly=rn4_chrominfo, chromosomes='chr12')
#'}
#'# Obtain the univariate fits
#'models <- list()
#'for (i1 in 1:length(binned.data)) {
#'  models[[i1]] <- callPeaksUnivariate(binned.data[[i1]], ID=names(binned.data)[i1],
#'                                      max.time=60, eps=1)
#'}
#'# Construct experiment structure
#'exp <- data.frame(file=bedfiles, mark=c("H3K27me3","H3K27me3","H3K4me3","H3K4me3"),
#'                  condition=rep("SHR",4), replicate=c(1:2,1:2), pairedEndReads=FALSE)
#'states <- stateBrewer(exp, mode='mark')
#'# Call multivariate peaks
#'multimodel <- callPeaksMultivariate(models, use.states=states, eps=1, max.time=60)
#'# Check some plots
#'plot(multimodel, type='transitionMatrix')
#'plot(multimodel, type='correlation')
#'
callPeaksMultivariate <- function(hmms, use.states, max.states=NULL, per.chrom=TRUE, chromosomes=NULL, eps=0.01, post.cutoff=NULL, keep.posteriors=FALSE, num.threads=1, max.time=NULL, max.iter=NULL, keep.densities=FALSE, verbosity=1) {

    ## Intercept user input
    if (!is.null(use.states)) {
        if (class(use.states)!='data.frame') stop("argument 'use.states' expects a data.frame generated by function 'state.brewer'")
    }
    if (!is.null(max.states)) {
        if (check.positive.integer(max.states)!=0) stop("argument 'max.states' expects a positive integer")
    }
    if (!is.null(use.states) & !is.null(max.states)) {
        if (max.states > nrow(use.states)) {
            max.states <- nrow(use.states)
        }
    }
    if (check.positive(eps)!=0) stop("argument 'eps' expects a positive numeric")
    if (check.positive.integer(num.threads)!=0) stop("argument 'num.threads' expects a positive integer")
    if (is.null(max.time)) { max.time <- -1 } else if (check.nonnegative.integer(max.time)!=0) { stop("argument 'max.time' expects a non-negative integer") }
    if (is.null(max.iter)) { max.iter <- -1 } else if (check.nonnegative.integer(max.iter)!=0) { stop("argument 'max.iter' expects a non-negative integer") }
    if (check.logical(keep.posteriors)!=0) stop("argument 'keep.posteriors' expects a logical (TRUE or FALSE)")
    if (check.logical(keep.densities)!=0) stop("argument 'keep.densities' expects a logical (TRUE or FALSE)")
    if (check.integer(verbosity)!=0) stop("argument 'verbosity' expects an integer")
    if (!is.null(post.cutoff)) {
        if (post.cutoff>1 | post.cutoff<0) stop("argument 'post.cutoff' has to be between 0 and 1 if specified")
    }
    if (length(hmms)<=1) {
        stop("argument 'hmms' is of length=1. Cannot call multivariate peaks with only one model.")
    }

    ## Prepare the HMM
    p <- prepareMultivariate(hmms, use.states=use.states, max.states=max.states, chromosomes=chromosomes)

    if (is.null(chromosomes)) {
        chromosomes <- seqlevels(p$bins)
    }

    ## Run multivariate per chromosome
    if (per.chrom) {

        # Set up parallel execution
        if (num.threads > 1) {
            ptm <- startTimedMessage("Setting up parallel multivariate with ", num.threads, " threads ...")
            cl <- parallel::makeCluster(num.threads)
            doParallel::registerDoParallel(cl)
            on.exit(
                if (num.threads > 1) {
                    parallel::stopCluster(cl)
                }
            )
            stopTimedMessage(ptm)
        }

        # Run the multivariate
        chrom <- NULL # please BiocCheck
        if (num.threads > 1) {
            ptm <- startTimedMessage("Running multivariate ...")
            models <- foreach (chrom = chromosomes, .packages='chromstaR') %dopar% {
                bins <- p$bins[seqnames(p$bins)==chrom]
                model <- runMultivariate(bins=bins, IDs=p$IDs, comb.states=p$comb.states, use.states=p$use.states, distributions=p$distributions, weights=p$weights, correlationMatrix=p$correlationMatrix, correlationMatrixInverse=p$correlationMatrixInverse, determinant=p$determinant, max.iter=max.iter, max.time=max.time, eps=eps, num.threads=1, post.cutoff=post.cutoff, keep.posteriors=keep.posteriors, keep.densities=keep.densities, verbosity=verbosity)
                model
            }
            stopTimedMessage(ptm)
        } else {
            models <- foreach (chrom = chromosomes, .packages='chromstaR') %do% {
                ptm <- startTimedMessage("Chromosome = ", chrom, "\n")
                bins <- p$bins[seqnames(p$bins)==chrom]
                model <- suppressMessages( runMultivariate(bins=bins, IDs=p$IDs, comb.states=p$comb.states, use.states=p$use.states, distributions=p$distributions, weights=p$weights, correlationMatrix=p$correlationMatrix, correlationMatrixInverse=p$correlationMatrixInverse, determinant=p$determinant, max.iter=max.iter, max.time=max.time, eps=eps, num.threads=1, post.cutoff=post.cutoff, keep.posteriors=keep.posteriors, keep.densities=keep.densities, verbosity=verbosity) )
                message("Time spent for chromosome = ", chrom, ":", appendLF=FALSE)
                stopTimedMessage(ptm)
                model
            }
        }

        # Merge chromosomes into one multiHMM
        ptm <- startTimedMessage("Merging chromosomes ...")
        model <- suppressMessages( mergeChroms(models) )
        stopTimedMessage(ptm)

    ## Run multivariate for all chromosomes
    } else {

        model <- runMultivariate(bins=p$bins, IDs=p$IDs, comb.states=p$comb.states, use.states=p$use.states, distributions=p$distributions, weights=p$weights, correlationMatrix=p$correlationMatrix, correlationMatrixInverse=p$correlationMatrixInverse, determinant=p$determinant, max.iter=max.iter, max.time=max.time, eps=eps, num.threads=num.threads, post.cutoff=post.cutoff, keep.posteriors=keep.posteriors, keep.densities=keep.densities, verbosity=verbosity)

    }

    return(model)

}


runMultivariate <- function(bins, IDs, comb.states, use.states, distributions, weights, correlationMatrix, correlationMatrixInverse, determinant, max.iter, max.time, eps, num.threads, post.cutoff, keep.posteriors, keep.densities, transitionProbs.initial=NULL, startProbs.initial=NULL, verbosity=1) {

    ptm <- startTimedMessage("Starting multivariate HMM with ", length(comb.states), " combinatorial states")
    message("")

    ### Define cleanup behaviour ###
    on.exit(.C("C_multivariate_cleanup", as.integer(ncol(bins$counts))))

    # Prepare input for C function
    rs <- unlist(lapply(distributions,"[",2:3,'size'))
    ps <- unlist(lapply(distributions,"[",2:3,'prob'))
    ws1 <- unlist(lapply(weights,"[",1))
    ws2 <- unlist(lapply(weights,"[",2))
    ws3 <- unlist(lapply(weights,"[",3))
    ws <- ws1 / (ws2+ws1)
    get.posteriors <- TRUE
    if (get.posteriors) { lenPosteriors <- length(bins) * length(comb.states) } else { lenPosteriors <- 1 }
    if (keep.densities) { lenDensities <- length(bins) * length(comb.states) } else { lenDensities <- 1 }

    if (is.null(transitionProbs.initial)) {
        transitionProbs.initial <- matrix((1-0.9)/(length(comb.states)-1), ncol=length(comb.states), nrow=length(comb.states))
        diag(transitionProbs.initial) <- 0.9
    }
    if (is.null(startProbs.initial)) {
        startProbs.initial <- rep(1/length(comb.states), length(comb.states))
    }

    # Call the C function
    hmm <- .C("C_multivariate_hmm",
        counts = as.integer(as.vector(bins$counts)), # int* multiO
        num.bins = as.integer(length(bins)), # int* T
        max.states = as.integer(length(comb.states)), # int* N
        num.modifications = as.integer(ncol(bins$counts)), # int* Nmod
        comb.states = as.integer(comb.states), # int* comb_states
        size = as.double(rs), # double* size
        prob = as.double(ps), # double* prob
        w = as.double(ws), # double* w
        correlation.matrix.inverse = as.double(correlationMatrixInverse), # double* cor_matrix_inv
        determinant = as.double(determinant), # double* det
        num.iterations = as.integer(max.iter), # int* maxiter
        time.sec = as.integer(max.time), # double* maxtime
        loglik.delta = as.double(eps), # double* eps
        posteriors = double(length=lenPosteriors), # double* posteriors
        get.posteriors = as.logical(get.posteriors), # bool* keep_posteriors
        densities = double(length=lenDensities), # double* densities
        keep.densities = as.logical(keep.densities), # bool* keep_densities
        states = integer(length=length(bins)), # int* states
        A = double(length=length(comb.states)*length(comb.states)), # double* A
        proba = double(length=length(comb.states)), # double* proba
        loglik = double(length=1), # double* loglik
        A.initial = as.double(transitionProbs.initial), # double* initial A
        proba.initial = as.double(startProbs.initial), # double* initial proba
        use.initial.params = as.logical(TRUE), # bool* use_initial_params
        num.threads = as.integer(num.threads), # int* num_threads
        error = as.integer(0), # error handling
        verbosity = as.integer(verbosity) # int* verbosity
        )
            
    ### Check convergence ###
    if (hmm$error == 1) {
        stop("A nan occurred during the Baum-Welch! Parameter estimation terminated prematurely. Check your read counts for very high numbers, they could be the cause for this problem.")
    } else if (hmm$error == 2) {
        stop("An error occurred during the Baum-Welch! Parameter estimation terminated prematurely.")
    }

    message("Time spent in multivariate HMM: ", appendLF=FALSE)
    stopTimedMessage(ptm)

    ### Make return object ###
        result <- list()
        result$IDs <- IDs
    ## Bin coordinates, posteriors and states
        result$bins <- bins
        if (get.posteriors) {
            ptm <- startTimedMessage("Transforming posteriors to `per sample` representation ...")
            hmm$posteriors <- matrix(hmm$posteriors, ncol=hmm$max.states)
            colnames(hmm$posteriors) <- paste0("P(",hmm$comb.states,")")
            result$bins$score <- do.call(pmax,as.list(as.data.frame(hmm$posteriors)))
            binstates <- dec2bin(hmm$comb.states, ndigits=hmm$num.modifications)
            post.per.track <- hmm$posteriors %*% binstates
            colnames(post.per.track) <- result$IDs
            result$bins$posteriors <- post.per.track
            stopTimedMessage(ptm)
        }
        ptm <- startTimedMessage("Calculating states from posteriors ...")
        if (!is.null(use.states$state)) {
            state.levels <- levels(use.states$state)
        } else {
            state.levels <- hmm$comb.states
        }
        if (!is.null(post.cutoff)) {
            result$bins$state <- factor(bin2dec(result$bins$posteriors >= post.cutoff), levels=state.levels)
        } else {
            result$bins$state <- factor(hmm$states, levels=state.levels)
        }
        stopTimedMessage(ptm)
        if (keep.densities) {
            result$bins$densities <- matrix(hmm$densities, ncol=hmm$max.states)
            colnames(result$bins$densities) <- hmm$comb.states
        }
    ## Add combinations
        mapping <- NULL
        result$bins$combination <- NA
        if (!is.null(use.states)) {
            mapping <- use.states$combination
            names(mapping) <- use.states$state
            result$bins$combination <- factor(mapping[as.character(result$bins$state)], levels=levels(use.states$combination))
        }
    ## Segmentation
        ptm <- startTimedMessage("Making segmentation ...")
        df <- as.data.frame(result$bins)
        ind.readcols <- grep('^counts', names(df))
        ind.postcols <- grep('^posteriors', names(df))
        ind.widthcol <- grep('width', names(df))
        ind.scorecol <- grep('score', names(df))
        red.df <- suppressMessages(collapseBins(df, column2collapseBy='state', columns2average=c(ind.postcols, ind.scorecol), columns2drop=c(ind.readcols, ind.widthcol)))
        mean.posteriors <- matrix(unlist(red.df[,grepl('^mean.posteriors',names(red.df))]), ncol=length(result$IDs))
        colnames(mean.posteriors) <- result$IDs
        mean.score <- red.df[,grepl('^mean.score', names(red.df))]
        red.gr <- GRanges(seqnames=red.df[,1], ranges=IRanges(start=red.df[,2], end=red.df[,3]), strand=red.df[,4], state=red.df[,'state'], combination=red.df[,'combination'], score=mean.score)
        red.gr$mean.posteriors <- mean.posteriors
        result$segments <- red.gr
        seqlengths(result$segments) <- seqlengths(result$bins)
        if (!keep.posteriors) {
            result$bins$posteriors <- NULL
        }
        stopTimedMessage(ptm)
    ## Parameters
        result$mapping <- mapping
        combinations <- mapping[as.character(comb.states)]
        # Weights
        tstates <- table(hmm$states)
        result$weights <- sort(tstates/sum(tstates), decreasing=TRUE)
        result$weights.univariate <- weights
        # Transition matrices
        result$transitionProbs <- matrix(hmm$A, ncol=length(comb.states), byrow=TRUE)
        colnames(result$transitionProbs) <- combinations
        rownames(result$transitionProbs) <- combinations
        result$transitionProbs.initial <- matrix(hmm$A.initial, ncol=length(comb.states), byrow=TRUE)
        colnames(result$transitionProbs.initial) <- combinations
        rownames(result$transitionProbs.initial) <- combinations
        # Initial probs
        result$startProbs <- hmm$proba
        names(result$startProbs) <- combinations
        result$startProbs.initial <- hmm$proba.initial
        names(result$startProbs.initial) <- combinations
        # Distributions
        result$distributions <- distributions
        names(result$distributions) <- IDs
        # post.cutoff
        result$post.cutoff <- post.cutoff
    ## Convergence info
        convergenceInfo <- list(eps=eps, loglik=hmm$loglik, loglik.delta=hmm$loglik.delta, num.iterations=hmm$num.iterations, time.sec=hmm$time.sec)
        result$convergenceInfo <- convergenceInfo
    ## Correlation matrices
        result$correlation.matrix <- correlationMatrix
    ## Add class
        class(result) <- class.multivariate.hmm
    
    ## Check convergence
    if (result$convergenceInfo$loglik.delta > result$convergenceInfo$eps) {
        war <- warning("HMM did not converge!\n")
    }
    return(result)

}


#' @importFrom stats pnbinom qnorm dnbinom
prepareMultivariate = function(hmms, use.states=NULL, max.states=NULL, chromosomes=NULL) {

    nummod <- length(hmms)

    ## Load first HMM for coordinates
    ptm <- startTimedMessage("Getting coordinates ...")
    hmm <- suppressMessages( loadHmmsFromFiles(hmms[[1]], check.class=class.univariate.hmm)[[1]] )
    bins <- hmm$bins
    mcols(bins) <- NULL
    stopTimedMessage(ptm)

    if (!is.null(chromosomes)) {
        chromsNotInData <- setdiff(chromosomes, unique(seqnames(bins)))
        if (length(chromsNotInData) == length(chromosomes)) {
            stop("None of the specified chromosomes '", paste0(chromsNotInData, collapse=', '), "' exists.")
        }
        if (length(chromsNotInData)>0) {
            warning("Chromosomes '", paste0(chromsNotInData, collapse=', '), "' could not be found.")
        }
    }

    ## Go through HMMs and extract stuff
    ptm <- startTimedMessage("Extracting read counts ...")
    IDs <- hmm$ID
    distributions <- list(hmm$distributions)
    weights <- list(hmm$weights)
    counts <- matrix(NA, ncol=nummod, nrow=length(bins))
    counts[,1] <- hmm$bins$counts
    binary_statesmatrix <- matrix(NA, ncol=nummod, nrow=length(bins))
    binary_statesmatrix[,1] <- c(FALSE,FALSE,TRUE)[hmm$bins$state]
    for (i1 in 2:nummod) {
        hmm <- suppressMessages( loadHmmsFromFiles(hmms[[i1]], check.class=class.univariate.hmm)[[1]] )
        IDs[i1] <- hmm$ID
        distributions[[i1]] <- hmm$distributions
        weights[[i1]] <- hmm$weights
        counts[,i1] <- hmm$bins$counts
        binary_statesmatrix[,i1] <- c(FALSE,FALSE,TRUE)[hmm$bins$state] # F,F,T corresponds to levels 'zero-inflation','unmodified','modified'
    }
    bins$counts <- counts
    colnames(bins$counts) <- IDs
    maxcounts <- max(bins$counts)
    bins$binary_statesmatrix <- binary_statesmatrix
    if (!is.null(chromosomes)) {
        # Select only specified chromosomes
        bins <- bins[seqnames(bins) %in% chromosomes]
    }
    stopTimedMessage(ptm)

    # Clean up to reduce memory usage
    remove(hmm)

    ## Transform binary to decimal
    ptm <- startTimedMessage("Getting combinatorial states")
    decimal_states <- rep(0,length(bins))
    for (imod in 1:nummod) {
        decimal_states <- decimal_states + 2^(nummod-imod) * bins$binary_statesmatrix[,imod]
    }
    bins$binary_statesmatrix <- NULL
    bins$state <- decimal_states
    if (is.null(use.states)) {
        comb.states.table <- sort(table(bins$state), decreasing=TRUE)
        comb.states <- names(comb.states.table)
    } else {
        comb.states.table <- sort(table(bins$state)[as.character(use.states$state)], decreasing=TRUE)
        comb.states <- names(comb.states.table)
        comb.states <- c(comb.states, setdiff(use.states$state, comb.states))
    }
    # Subselect states
    numstates2use <- min(length(comb.states), max.states)
    comb.states <- comb.states[1:numstates2use]
    stopTimedMessage(ptm)

    ## We pre-compute the z-values for each number of counts
    ptm <- startTimedMessage("Computing pre z-matrix...")
    z.per.read <- array(NA, dim=c(maxcounts+1, nummod, 2))
    xcounts = 0:maxcounts
    for (imod in 1:nummod) {
        # Go through unmodified and modified
        for (i1 in 2:3) {
            
            size = distributions[[imod]][i1,'size']
            prob = distributions[[imod]][i1,'prob']

            if (i1 == 2) {
                # Unmodified with zero inflation
                w = weights[[imod]][1] / (weights[[imod]][2] + weights[[imod]][1])
                u = pzinbinom(xcounts, w, size, prob)
            } else if (i1 == 3) {
                # Modified
                u = stats::pnbinom(xcounts, size, prob)
            }

            # Check for infinities in u and set them to max value which is not infinity
            qnorm_u = stats::qnorm(u)
            mask <- qnorm_u==Inf
            qnorm_u[mask] <- stats::qnorm(1-1e-16)
#             testvec = qnorm_u!=Inf
#             qnorm_u = ifelse(testvec, qnorm_u, max(qnorm_u[testvec]))
            z.per.read[ , imod, i1-1] <- qnorm_u

        }
    }
    stopTimedMessage(ptm)

    ## Compute the z matrix
    ptm <- startTimedMessage("Transfering values into z-matrix...")
    z.per.bin = array(NA, dim=c(length(bins), nummod, 2), dimnames=list(bin=1:length(bins), track=IDs, state.labels[2:3]))
    for (imod in 1:nummod) {
        for (i1 in 1:2) {
            z.per.bin[ , imod, i1] <- z.per.read[bins$counts[,imod]+1, imod, i1]
        }
    }

    # Clean up to reduce memory usage
    remove(z.per.read)
    stopTimedMessage(ptm)

    ### Calculate correlation matrix
    ptm <- startTimedMessage("Computing inverse of correlation matrix...")
    correlationMatrix = array(NA, dim=c(nummod,nummod,length(comb.states)), dimnames=list(track=IDs, track=IDs, comb.state=comb.states))
    correlationMatrixInverse = array(NA, dim=c(nummod,nummod,length(comb.states)), dimnames=list(track=IDs, track=IDs, comb.state=comb.states))
    determinant = rep(NA, length(comb.states))
    names(determinant) <- comb.states

    ## Calculate correlation matrix serial
    for (state in comb.states) {
        istate = which(comb.states==state)
        mask = which(bins$state==as.integer(state))
        # Convert state to binary representation
        binary_state = rev(as.integer(intToBits(as.integer(state)))[1:nummod])
        # Subselect z
        z.temp <- matrix(NA, ncol=nummod, nrow=length(mask))
        for (i1 in 1:length(binary_state)) {
            z.temp[,i1] <- z.per.bin[mask, i1, binary_state[i1]+1]
        }
        temp <- tryCatch({
            if (nrow(z.temp) > 100) {
                correlationMatrix[,,istate] <- cor(z.temp)
                determinant[istate] <- det( correlationMatrix[,,istate] )
                correlationMatrixInverse[,,istate] <- chol2inv(chol(correlationMatrix[,,istate]))
            } else {
                correlationMatrix[,,istate] <- diag(nummod)
                determinant[istate] <- 1 # det(diag(x)) == 1
                correlationMatrixInverse[,,istate] <- diag(nummod) # solve(diag(x)) == diag(x)
            }
            0
        }, warning = function(war) {
            1
        }, error = function(err) {
            1
        })
        if (temp!=0) {
            correlationMatrix[,,istate] <- diag(nummod)
            determinant[istate] <- 1
            correlationMatrixInverse[,,istate] <- diag(nummod)
        }
        if (any(is.na(correlationMatrixInverse[,,istate]))) {
            correlationMatrixInverse[,,istate] <- diag(nummod)
        }
    }
    remove(z.per.bin)
    stopTimedMessage(ptm)

#     ## Calculate emission densities (only debugging, do in C++ otherwise)
#     densities <- matrix(1, ncol=numstates2use, nrow=length(bins))
#     for (comb.state in comb.states) {
# print(comb.state)
#         istate <- which(comb.state==comb.states)
#         z.temp <- matrix(NA, nrow=length(bins), ncol=nummod)
#         bin.comb.state <- dec2bin(comb.state, colnames=IDs)
#         product <- 1
#         for (imod in 1:nummod) {
#             z.temp[,imod] <- z.per.bin[,imod,bin.comb.state[imod]+1]
#             ind.modstate <- bin.comb.state[imod]+2
#             if (rownames(distributions[[imod]])[ind.modstate] == 'unmodified') {
#                 size <- distributions[[imod]][ind.modstate,'size']
#                 prob <- distributions[[imod]][ind.modstate,'prob']
#                 product <- product * dzinbinom(bins$counts[,imod], w=weights[[imod]]['zero-inflation'], size, prob)
#             } else if (rownames(distributions[[imod]])[ind.modstate] == 'modified') {
#                 size <- distributions[[imod]][ind.modstate,'size']
#                 prob <- distributions[[imod]][ind.modstate,'prob']
#                 product <- product * stats::dnbinom(bins$counts[,imod], size, prob)
#             }
#         }
#         exponent <- -0.5 * apply( ( z.temp %*% (correlationMatrixInverse[ , , istate] - diag(nummod)) ) * z.temp, 1, sum)
#         densities[,istate] <- product * determinant[istate]^(-0.5) * exp( exponent )
#     }

    # Return parameters
    out = list(IDs = IDs,
                bins = bins,
                comb.states = comb.states,
                use.states = use.states,
                distributions = distributions,
                weights = weights,
                correlationMatrix = correlationMatrix,
                correlationMatrixInverse = correlationMatrixInverse,
                determinant = determinant
    )
    return(out)
}

