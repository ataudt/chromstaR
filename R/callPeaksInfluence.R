#' Fit a Hidden Markov Model to multiple ChIP-seq samples
#'
#' Fit a HMM to multiple ChIP-seq samples to determine the combinatorial state of genomic regions. Input is a list of \code{\link{uniHMM}}s generated by \code{\link{callPeaksUnivariate}}.
#'
#' TODO: Emission distributions from the univariate HMMs are used with a Gaussian copula to generate a multivariate emission distribution for each combinatorial state. This multivariate distribution is then kept fixed and the transition probabilities are fitted with a Baum-Welch. Please refer to our manuscript at \url{http://dx.doi.org/10.1101/038612} for a detailed description of the method.
#'
#' @author Aaron Taudt, Luisa Santus
#' @param hmms A list of \code{\link{uniHMM}}s generated by \code{\link{callPeaksUnivariate}}, e.g. \code{list(hmm1,hmm2,...)} or a vector of files that contain such objects, e.g. \code{c("file1","file2",...)}.
#' @param per.chrom If \code{per.chrom=TRUE} chromosomes will be treated separately. This tremendously speeds up the calculation but results might be noisier as compared to \code{per.chrom=FALSE}, where all chromosomes are concatenated for the HMM.
#' @param chromosomes A vector specifying the chromosomes to use from the models in \code{hmms}. The default (\code{NULL}) uses all available chromosomes.
#' @param eps Convergence threshold for the Baum-Welch algorithm.
#' @param keep.posteriors If set to \code{TRUE}, posteriors will be available in the output. This can be useful to change the posterior cutoff later, but increases the necessary disk space to store the result immensely.
#' @param num.threads Number of threads to use. Setting this to >1 may give increased performance.
#' @param max.time The maximum running time in seconds for the Baum-Welch algorithm. If this time is reached, the Baum-Welch will terminate after the current iteration finishes. The default \code{NULL} is no limit.
#' @param max.iter The maximum number of iterations for the Baum-Welch algorithm. The default \code{NULL} is no limit.
#' @param keep.densities If set to \code{TRUE} (default=\code{FALSE}), densities will be available in the output. This should only be needed debugging.
#' @param verbosity Verbosity level for the fitting procedure. 0 - No output, 1 - Iterations are printed.
#' @param temp.savedir A directory where to store intermediate results if \code{per.chrom=TRUE}.
#' @param update.tiestrengths Set to \code{FALSE} if you don't want to update the tiestrengths during Baum-Welch training.
#' @return A \code{\link{multiHMM}} object.
#' @seealso \code{\link{multiHMM}}, \code{\link{callPeaksUnivariate}}, \code{\link{callPeaksReplicates}}
#' @import doParallel
#' @import foreach
#' @export
#' @examples
#'# Get example BAM files for 2 different marks in hypertensive rat
#'file.path <- system.file("extdata","euratrans", package='chromstaRData')
#'files <- list.files(file.path, full.names=TRUE, pattern='SHR.*bam$')[c(1:5)]
#'# Construct experiment structure
#'exp <- data.frame(file=files, mark=c(rep("H3K27me3",3), rep("H3K4me3", 2)),
#'                  condition=rep("SHR",5), replicate=c(1:3,1:2), pairedEndReads=FALSE,
#'                  controlFiles=NA)
#'# Bin the data
#'data(rn4_chrominfo)
#'binned.data <- list()
#'for (file in files) {
#'  binned.data[[basename(file)]] <- binReads(file, binsizes=1000, stepsizes=500,
#'                                            experiment.table=exp,
#'                                            assembly=rn4_chrominfo, chromosomes='chr12')
#'}
#'# Obtain the univariate fits
#'models <- list()
#'for (i1 in 1:length(binned.data)) {
#'  models[[i1]] <- callPeaksUnivariate(binned.data[[i1]], max.time=60, eps=1)
#'}
#'# Call multivariate peaks
#'multimodel <- callPeaksInfluence(models, eps=1, max.time=60)
#'# Check some plots
#'heatmapTransitionProbs(multimodel)
#'heatmapTiestrengths(multimodel)
#'heatmapCountCorrelation(multimodel)
#'



#__________________________________________________________________________________________________________        
#----------------------------------------------------------------------------------------------------------        
#                       OVERVIEW: correspondence of variable names among R and C++ code
# ---------------------------------------------------------------------------------------------------------       
#
#        
#    R code                         C++ code                     Dimension(C++)          Description           
#           
#    num.bins                       T                            int*                    Number of time points   
#    max.states                     N                            int*                    Number of states       
#    num.modifications              Nmod                         int*                    Number of modifications 
#    comb.states                    comb_states                  double*                 States that exist for each chain ( either 0 or 1)
#    size                           size                         double*                 Parameter for the negative binomial distribution
#    prob                           prob                         double*                 Parameter for the negative binomial distribution
#    w                              w                            double*                 Parameter for the ZeroInflated negative binomial distribution
#    num.iterations                 maxiter                      int*                    Maximal number of iterations allowed
#    time.sec                       maxtime                      int*                    Maximal number of seconds allowed for completing the computation 
#    loglik.delta                   eps                          double*                 Defines the value where convergence is defined to be reached (when dLogP is lower then this value convergence is reached)
#    posteriors                     gamma                        double***               Describes the probability of being in specific state at a time point t in correspondence of a specific modification
#    get.posteriors                 keep_posteriors              bool*                   If set to true the gammas (posteriors) are kept
#    densities                      densities                    double***               The observation symbol probability distribution in a given state (See NOTES for dimension correspondence)
#    keep.densities                 keep_densities               bool*                   If set to true the densities are kept
#    states                         states                       double**                Total number of modifications in all different timepoints (Nmod*T)
#    maxPosterior                   maxPosterior                 double*                 Maximum of the posteriors (gammas)
#    A                              A                            double*                 State transition probabilities matrix (See NOTES for dimension correspondence)
#    proba                          proba                        double**                Initial state distributions (See NOTES for dimensions correspondence)
#    tiestrength                    tiestrength                  double*                 Tiestrenghts (See NOTES for dimensions correspondence)
#    update.tiestrengths            update_tiestrengths          bool*                   If set to TRUE tiestrengths are updated in the C++ code
#    A.initial                      initial A                    double*                 Initial values for the state transition matrix (See NOTES for dimensions correspondence)
#    proba.initial                  initial proba                double*                 Initial value for the (See NOTES for dimensions correspondence) 
#    tiestrength.initial            initial tiestrength          double*                 Initial values for the tiestrengths ( See NOTES for dimensions correspondence)
#    use_initial_params             use_initial_params           bool*                   If set to true, the initial parameters are used for the initialization
#    num.threads                    num_threads                  int*                    Number of threads to be used
#    verbosity                      verbosity                    int*                    Defines the completeness of the printed messages: the higher it is, the completer are the messages. 
#
#
#    NOTE: In the R code matrixes are represented flattened; they have only one dimension and the length corresponds 
#          to the product of the lengths of all the dimension of the matrix.          
#        
#---------------------------------------------------------------------------------------------------------- 

callPeaksInfluence <- function(hmms, per.chrom=TRUE, chromosomes=NULL, eps=0.01, keep.posteriors=FALSE, num.threads=1, max.time=NULL, max.iter=NULL, keep.densities=FALSE, verbosity=1, temp.savedir=NULL, update.tiestrengths=TRUE) {

    ## Intercept user input
    if (check.positive(eps)!=0) stop("argument 'eps' expects a positive numeric")
    if (check.positive.integer(num.threads)!=0) stop("argument 'num.threads' expects a positive integer")
    if (is.null(max.time)) { max.time <- -1 } else if (check.nonnegative.integer(max.time)!=0) { stop("argument 'max.time' expects a non-negative integer") }
    if (is.null(max.iter)) { max.iter <- -1 } else if (check.nonnegative.integer(max.iter)!=0) { stop("argument 'max.iter' expects a non-negative integer") }
    if (check.logical(keep.posteriors)!=0) stop("argument 'keep.posteriors' expects a logical (TRUE or FALSE)")
    if (check.logical(keep.densities)!=0) stop("argument 'keep.densities' expects a logical (TRUE or FALSE)")
    if (check.logical(update.tiestrengths)!=0) stop("argument 'keep.tiestrengths' expects a logical (TRUE or FALSE)")
    if (check.integer(verbosity)!=0) stop("argument 'verbosity' expects an integer")
    if (length(hmms)==0) {
        stop("argument 'hmms' is of length=0. Cannot call multivariate peaks with no models.")
    }
    if (length(hmms)==1) {
        hmm <- loadHmmsFromFiles(hmms, check.class=class.univariate.hmm)[[1]]
        ### Make return object ###
            result <- list()
            result$info <- hmm$info
            if (is.null(result$info)) {
                n <- 1
                result$info <- data.frame(file=rep(NA, n), mark=1:n, condition=1:n, replicate=1, pairedEndReads=rep(NA, n), controlFiles=rep(NA, n))
                result$info$ID <- paste0(result$info$mark, '-', result$info$condition, '-rep', result$info$replicate)
            }
        ## Counts
            result$bincounts <- hmm$bincounts
            result$bincounts$counts <- array(NA, dim = c(length(hmm$bincounts), 1, dim(hmm$bincounts$counts)[2]), dimnames = list(bin=NULL, track=result$info$ID, offset=dimnames(hmm$bincounts$counts)[[2]]))
            result$bincounts$counts[,1,] <- hmm$bincounts$counts
        ## Bin coordinates, posteriors and states
            result$bins <- hmm$bins
            result$bins$score <- NULL
            result$bins$posterior.modified <- NULL
            result$bins$counts.rpkm <- matrix(hmm$bins$counts.rpkm, ncol=1)
            result$bins$state <- factor(c(0,0,1))[hmm$bins$state]
            result$bins$posteriors <- matrix(hmm$bins$posterior.modified, ncol=1, dimnames=list(NULL, result$info$ID))
            result$bins$differential.score <- 0
        ## Add combinations
            use.states <- stateBrewer(experiment.table = result$info[, setdiff(names(result$info), 'ID'), drop=FALSE], mode = 'all')
            mapping <- NULL
            if (!is.null(use.states)) {
                mapping <- use.states$combination
                names(mapping) <- use.states$state
                result$bins$combination <- factor(mapping[as.character(result$bins$state)], levels=levels(use.states$combination))
            } else {
                result$bins$combination <- result$bins$state
            }
        ## Segmentation
            result$segments <- multivariateSegmentation(result$bins, column2collapseBy='state')
            mcols(result$segments)[2] <- NULL
            if (!keep.posteriors) {
                result$bins$posteriors <- NULL
            }
        ## Parameters
            result$mapping <- mapping
            combinations <- mapping[as.character(c(0,1))]
            # Weights
            tstates <- table(result$bins$state)
            result$weights <- sort(tstates/sum(tstates), decreasing=TRUE)
            result$weights.univariate <- list(hmm$weights)
            names(result$weights.univariate) <- result$info$ID
            # Transition matrices
            result$transitionProbs <- NA
            result$transitionProbs.initial <- NA
            # Initial probs
            result$startProbs <- NA
            result$startProbs.initial <- NA
            # Distributions
            result$distributions <- list(hmm$distributions)
            names(result$distributions) <- result$info$ID
        ## Convergence info
            convergenceInfo <- list(eps=NA, loglik=NA, loglik.delta=NA, num.iterations=NA, time.sec=NA)
            result$convergenceInfo <- convergenceInfo
        ## Correlation matrices
            result$correlation.matrix <- NA
        ## Add class
            class(result) <- class.multivariate.hmm
        
        return(result)
    }

    ## Prepare the HMM
    p <- prepareInfluence(hmms, chromosomes=chromosomes)

    if (is.null(chromosomes)) {
        chromosomes <- intersect(seqlevels(p$bincounts), unique(seqnames(p$bincounts)))
    }
    if (!is.null(temp.savedir)) {
        if (!file.exists(temp.savedir)) {
            dir.create(temp.savedir)
        }
    }

    ## Run multivariate per chromosome
    if (per.chrom) {

        # Set up parallel execution
        if (num.threads > 1) {
            ptm <- startTimedMessage("Setting up parallel multivariate with ", num.threads, " threads ...")
            cl <- parallel::makeCluster(num.threads)
            doParallel::registerDoParallel(cl)
            on.exit(
                if (num.threads > 1) {
                    parallel::stopCluster(cl)
                }
            )
            stopTimedMessage(ptm)
        }

        # Run the multivariate
        chrom <- NULL # please BiocCheck
        if (num.threads > 1) {
            ptm <- startTimedMessage("Running multivariate ...")
            models <- foreach (chrom = chromosomes, .packages='chromstaR') %dopar% {
                bincounts <- p$bincounts[seqnames(p$bincounts)==chrom]
                bins <- p$bins[seqnames(p$bins)==chrom]
                if (!is.null(temp.savedir)) {
                    temp.savename <- file.path(temp.savedir, paste0('chromosome_', chrom, '.RData'))
                    if (!file.exists(temp.savename)) {
                        model <- runInfluence(binned.data=bincounts, stepbins=bins, info=p$info, comb.states=p$comb.states, use.states=p$use.states, distributions=p$distributions, weights=p$weights, max.iter=max.iter, max.time=max.time, eps=eps, num.threads=1, keep.posteriors=keep.posteriors, keep.densities=keep.densities, update.tiestrengths=update.tiestrengths, verbosity=verbosity)
                        save(model, file=temp.savename)
                        rm(model); gc()
                    }
                    temp.savename
                } else {
                    model <- runInfluence(binned.data=bincounts, stepbins=bins, info=p$info, comb.states=p$comb.states, use.states=p$use.states, distributions=p$distributions, weights=p$weights, max.iter=max.iter, max.time=max.time, eps=eps, num.threads=1, keep.posteriors=keep.posteriors, keep.densities=keep.densities, update.tiestrengths=update.tiestrengths, verbosity=verbosity)
                    model
                }
            }
            stopTimedMessage(ptm)
        } else {
            models <- list()
            for (chrom in chromosomes) {
                ptm <- messageU("Chromosome = ", chrom, overline="-", underline=NULL)
                bincounts <- p$bincounts[seqnames(p$bincounts)==chrom]
                bins <- p$bins[seqnames(p$bins)==chrom]
                if (!is.null(temp.savedir)) {
                    temp.savename <- file.path(temp.savedir, paste0('chromosome_', chrom, '.RData'))
                    if (!file.exists(temp.savename)) {
                        model <- runInfluence(binned.data=bincounts, stepbins=bins, info=p$info, comb.states=p$comb.states, use.states=p$use.states, distributions=p$distributions, weights=p$weights, max.iter=max.iter, max.time=max.time, eps=eps, num.threads=1, keep.posteriors=keep.posteriors, keep.densities=keep.densities, update.tiestrengths=update.tiestrengths, verbosity=verbosity)
                        ptm <- startTimedMessage("Saving chromosome ", chrom, " to temporary file ", temp.savename, " ...")
                        save(model, file=temp.savename)
                        rm(model); gc()
                        stopTimedMessage(ptm)
                    }
                    models[[as.character(chrom)]] <- temp.savename
                } else {
                    model <- runInfluence(binned.data=bincounts, stepbins=bins, info=p$info, comb.states=p$comb.states, use.states=p$use.states, distributions=p$distributions, weights=p$weights, max.iter=max.iter, max.time=max.time, eps=eps, num.threads=1, keep.posteriors=keep.posteriors, keep.densities=keep.densities, update.tiestrengths=update.tiestrengths, verbosity=verbosity)
                    models[[as.character(chrom)]] <- model
                }
                message("Time spent for chromosome = ", chrom, ":", appendLF=FALSE)
                stopTimedMessage(ptm)
            }
        }

        # Merge chromosomes into one multiHMM
        ptm <- startTimedMessage("Merging chromosomes ...")
        if (!is.null(temp.savedir)) {
            models <- as.character(models) # make sure 'models' is a character vector with filenames and not a list()
        }
        model <- suppressMessages( mergeChroms(models) )
        stopTimedMessage(ptm)

    ## Run multivariate for all chromosomes
    } else {

        model <- runInfluence(binned.data=p$bincounts, stepbins=p$bins, info=p$info, comb.states=p$comb.states, use.states=p$use.states, distributions=p$distributions, weights=p$weights, max.iter=max.iter, max.time=max.time, eps=eps, num.threads=num.threads, keep.posteriors=keep.posteriors, keep.densities=keep.densities, update.tiestrengths=update.tiestrengths, verbosity=verbosity)

    }

    if (!is.null(temp.savedir)) {
        if (file.exists(temp.savedir)) {
            unlink(temp.savedir, recursive = TRUE)
        }
    }
    return(model)

}

#' @importFrom stats ecdf
runInfluence <- function(binned.data, stepbins, info, comb.states=use.states$state, use.states, distributions, weights, max.iter, max.time, eps, num.threads, keep.posteriors, keep.densities, transitionProbs.initial=NULL, tiestrength.initial=NULL, startProbs.initial=NULL, verbosity=1, update.tiestrengths=TRUE) {

    ptm.start <- startTimedMessage("Starting influence HMM with ", length(info$ID), " experiments")
    message("")

    ### Variables ###
    statenames <- c('unmodified', 'modified')
    numstates <- length(statenames)
    tracknames <- info$ID
    nummod <- dim(binned.data$counts)[2]
    offsets <- dimnames(binned.data$counts)[[3]]
    numbins <- length(binned.data)
    
    # Prepare input for C function
    rs <- unlist(lapply(distributions,"[",2:3,'size'))
    ps <- unlist(lapply(distributions,"[",2:3,'prob'))
    ws1 <- unlist(lapply(weights,"[",1))
    ws2 <- unlist(lapply(weights,"[",2))
    ws3 <- unlist(lapply(weights,"[",3))
    ws <- ws1 / (ws2+ws1)
    get.posteriors <- TRUE
    if (get.posteriors) { lenPosteriors <- numbins * numstates * nummod } else { lenPosteriors <- 1 }
    if (keep.densities) { lenDensities <- numbins * numstates * nummod } else { lenDensities <- 1 }


    if (is.null(transitionProbs.initial)) {
       
        transitionProbs.initial <- array((1-0.9)/(numstates-1), dim=c(numstates, numstates, nummod, nummod), dimnames= list(fromState=statenames, toState=statenames, fromTrack=tracknames, toTrack=tracknames))
        for (ic in 1:nummod) {
            for (jc in 1:nummod) {
                diag(transitionProbs.initial[,,ic,jc]) <- 0.9
            }
        }

    }
    
    if (is.null(tiestrength.initial)) {
      
      if (nummod == 1) {
          tiestrength.initial <- array(1, dim=c(nummod, nummod), dimnames= list(fromTrack=tracknames, toTrack=tracknames))
      } else {
          # tiestrength.initial <- array((1-0.9)/(nummod-1), dim=c(nummod, nummod), dimnames= list(fromTrack=tracknames, toTrack=tracknames))
          # diag(tiestrength.initial) <- 0.9
          cor <- abs(cor(binned.data$counts[,,'0']))
          tiestrength.initial <- sweep(x = cor, MARGIN = 1, STATS = rowSums(cor), FUN = '/')
      }
      
    }
    
    if (is.null(startProbs.initial)) {
        startProbs.initial <- array((1/numstates/nummod), dim=c(nummod, numstates), dimnames=list(track=tracknames, state=statenames))
    }
 

    ### Arrays for finding maximum posterior for each bin between offsets
    ## Make bins with offset
    ptm <- startTimedMessage("Making bins with offsets ...")
    ## Dummy bins without mcols for shifting
    sbins <- binned.data
    mcols(sbins) <- NULL
    ## Initialize arrays
    if (get.posteriors) {
        aposteriors.step <- array(0, dim = c(length(stepbins), numstates, nummod, 2), dimnames = list(bin=NULL, state=statenames, track=info$ID, offset=c('previousOffsets', 'currentOffset'))) # to store posteriors-per-sample for current and max-of-previous offsets
    }
    amaxPosterior.step <- array(0, dim = c(length(stepbins), nummod, 2), dimnames = list(bin=NULL, track=tracknames, offset=c('previousOffsets', 'currentOffset'))) # to store maximum posterior for current and max-of-previous offsets
    astates.step <- array(0, dim = c(length(stepbins), nummod, 2), dimnames = list(bin=NULL, track=tracknames, offset=c('previousOffsets', 'currentOffset'))) # to store states for current and max-of-previous offsets
    stopTimedMessage(ptm)
    
    ### Loop over offsets ###
    for (ioffset in 1:length(offsets)) {
      
        offset <- offsets[ioffset]
        if (ioffset > 1) {
            ptm <- startTimedMessage("Obtaining states for offset = ", offset, " ...")
            ## Run only one iteration (no updating) if we are already over ioffset=1
            max.iter <- 1
            transitionProbs.initial <- hmm.A
            startProbs.initial <- hmm.proba
            verbosity <- 0
        } else {
            ptm <- startTimedMessage("Fitting Hidden Markov Model for offset = ", offset, "\n")
        }
      
        # Call the C function
        on.exit(.C("C_influence_cleanup", as.integer(nummod)))
        hmm <- .C("C_influence_hmm",
            counts = as.integer(as.vector(binned.data$counts[,, offset])), # int* multiO
            num.bins = as.integer(numbins), # int* T
            max.states = as.integer(numstates), # int* N
            num.modifications = as.integer(nummod), # int* Nmod
            comb.states = as.numeric(c(0,1)), # double* comb_states
            size = as.double(rs), # double* size
            prob = as.double(ps), # double* prob
            w = as.double(ws), # double* w
            num.iterations = as.integer(max.iter), # int* maxiter
            time.sec = as.integer(max.time), # int* maxtime
            loglik.delta = as.double(eps), # double* eps
            posteriors = double(length=lenPosteriors), # double* posteriors
            get.posteriors = as.logical(get.posteriors), # bool* keep_posteriors
            densities = double(length=lenDensities), # double* densities
            keep.densities = as.logical(keep.densities), # bool* keep_densities
            states = double(length=numbins * nummod), # double* states
            maxPosterior = double(length=numbins*nummod), # double* maxPosterior
            A = double(length=numstates*numstates*nummod*nummod), # double* A
            proba = double(length=nummod*numstates), # double* proba
            tiestrength= double(length=nummod*nummod), # double* tiestrength
            update.tiestrengths = as.logical(update.tiestrengths), # bool* update_tiestrengths
            loglik = double(length=1), # double* loglik
            A.initial = as.double(transitionProbs.initial), # double* initial A
            proba.initial = as.double(startProbs.initial), # double* initial proba
            tiestrength.initial= as.double(tiestrength.initial),# double* initial_tiestrength
            use.initial.params = as.logical(TRUE), # bool* use_initial_params
            num.threads = as.integer(num.threads), # int* num_threads
            error = as.integer(0), # error handling
            verbosity = as.integer(verbosity) # int* verbosity
            )
        ### Check convergence ###
        if (hmm$error == 1) {
            stop("A nan occurred during the Baum-Welch! Parameter estimation terminated prematurely. Check your read counts for very high numbers, they could be the cause for this problem.")
        } else if (hmm$error == 2) {
            stop("An error occurred during the Baum-Welch! Parameter estimation terminated prematurely.")
        }
        
        ## States and maxPosterior
        dim(hmm$states) <- c(numbins, nummod)
        dimnames(hmm$states) <- list(bin=NULL, track=tracknames)
        dim(hmm$maxPosterior) <- c(numbins, nummod)
        dimnames(hmm$maxPosterior) <- list(bin=NULL, track=tracknames)
        
        if (ioffset == 1) {
            ### Make return object ###
                result <- list()
                result$info <- info
            ## Densities
                if (keep.densities) {
                    densities <- hmm$densities
                    dim(densities) <- c(numbins, numstates, nummod)
                    dimnames(densities) <- list(bin=NULL, state=statenames, track=tracknames)
                }
            ## Parameters
                if (!is.null(use.states)) {
                    mapping <- use.states$combination
                    names(mapping) <- use.states$state
                } else {
                    mapping <- NULL
                }
                result$mapping <- mapping
                combinations <- mapping[as.character(comb.states)]
                # Weights
                tstates <- table(bin2dec(hmm$states))
                result$weights <- sort(tstates/sum(tstates), decreasing=TRUE)
                result$weights.univariate <- weights
                names(result$weights.univariate) <- result$info$ID
                # Transition matrices
                result$transitionProbs <- array(hmm$A, dim=c(numstates, numstates, nummod, nummod), dimnames= list(fromState=statenames, toState=statenames, fromTrack=tracknames, toTrack=tracknames))
                result$transitionProbs.initial <- array(hmm$A.initial, dim=c(numstates, numstates, nummod, nummod), dimnames= list(fromState=statenames, toState=statenames, fromTrack=tracknames, toTrack=tracknames))
                # Tie strengths
                result$tiestrengths <- array(hmm$tiestrength, dim=c(nummod, nummod), dimnames= list(fromTrack=tracknames, toTrack=tracknames))
                result$tiestrengths.initial <- array(hmm$tiestrength.initial, dim=c(nummod, nummod), dimnames= list(fromTrack=tracknames, toTrack=tracknames))
                # Initial probs
                result$startProbs <- array(hmm$proba, dim=c(nummod, numstates), dimnames=list(track=tracknames, state=statenames))
                result$startProbs.initial <- array(hmm$proba.initial, dim=c(nummod, numstates), dimnames=list(track=tracknames, state=statenames))
                # Distributions
                result$distributions <- distributions
                names(result$distributions) <- result$info$ID
            ## Convergence info
                convergenceInfo <- list(eps=eps, loglik=hmm$loglik, loglik.delta=hmm$loglik.delta, num.iterations=hmm$num.iterations, time.sec=hmm$time.sec)
                result$convergenceInfo <- convergenceInfo
            ## Add class
                class(result) <- class.multivariate.hmm
            
            ## Check convergence
            if (result$convergenceInfo$loglik.delta > result$convergenceInfo$eps) {
                war <- warning("HMM did not converge!\n")
            }
        }
        
        ## Store counts and posteriors in list
        if (get.posteriors) {
            dim(hmm$posteriors) <- c(numbins, numstates, nummod)
            dimnames(hmm$posteriors) <- list(bin=NULL, state=statenames, track=tracknames)
            #hmm$posteriors <- sweep(x = hmm$posteriors, MARGIN = c(1,3), STATS = apply(hmm$posteriors, c(1,3), sum), FUN = '/') # normalize posteriors
        }
        dim(hmm$counts) <- c(numbins, nummod)
        dimnames(hmm$counts) <- list(bin=NULL, track=info$ID)
        hmm.A <- hmm$A
        hmm.proba <- hmm$proba
        
        ## Transform posteriors to 'per-sample' representation
        if (get.posteriors) {
            post.per.track <- hmm$posteriors
        }
        
        ## Inflate posteriors, states, counts to new offset
        bins.shift <- suppressWarnings( shift(sbins, shift = as.numeric(offset)) )
        ind <- findOverlaps(stepbins, bins.shift)
        if (get.posteriors) {
            aposteriors.step[ind@from, , , 'currentOffset'] <- post.per.track[ind@to, , , drop=FALSE]
        }
        astates.step[ind@from, , 'currentOffset'] <- hmm$states[ind@to, , drop=FALSE]
        amaxPosterior.step[ind@from, , 'currentOffset'] <- hmm$maxPosterior[ind@to, , drop=FALSE]
        
        ## Find offset that maximizes the posteriors for each bin
        for (itrack in 1:dim(amaxPosterior.step)[2]) {
            x <- amaxPosterior.step[, itrack, ]
            ##-- Start stuff to call C code
            # Work with changing dimensions to avoid copies being made
            dim_x <- dim(x)
            dimnames_x <- dimnames(x)
            dim(x) <- NULL
            z <- .C("C_array2D_which_max",
                    array2D = x,
                    dim = as.integer(dim_x),
                    ind_max = integer(dim_x[1]),
                    value_max = double(dim_x[1]))
            dim(x) <- dim_x
            dimnames(x) <- dimnames_x
            ind <- z$ind_max
            ##-- End stuff to call C code
            for (i1 in 1:2) {
                mask <- ind == i1
                if (get.posteriors) {
                    aposteriors.step[mask, , itrack, 'previousOffsets'] <- aposteriors.step[mask,,itrack,i1, drop=FALSE]
                }
                astates.step[mask, itrack, 'previousOffsets'] <- astates.step[mask,itrack,i1, drop=FALSE]
                amaxPosterior.step[mask, itrack, 'previousOffsets'] <- amaxPosterior.step[mask,itrack,i1, drop=FALSE]
            }
        }
        
        if (ioffset == 1) {
            message("Time spent in multivariate HMM: ", appendLF=FALSE)
        }
        stopTimedMessage(ptm)
    
        rm(hmm, ind); gc()
    } # loop over offsets
    ptm <- startTimedMessage("Collecting states and posteriors over offsets ...")
    bin <- astates.step[, , 'previousOffsets']
    dim(bin) <- dim(astates.step)[1:2]
    dimnames(bin) <- dimnames(astates.step)[1:2]
    states.step <- bin2dec(bin)
    rm(amaxPosterior.step, astates.step, bin); gc()

    # Collect posteriors
    if (get.posteriors) {
        stepbins$posteriors <- aposteriors.step[,'modified',,'previousOffsets']
        dim(stepbins$posteriors) <- dim(aposteriors.step)[c(1,3)]
        dimnames(stepbins$posteriors) <- dimnames(aposteriors.step)[c(1,3)]
        rm(aposteriors.step); gc()
    }
    stopTimedMessage(ptm)
    
    ptm <- startTimedMessage("Compiling coordinates, posteriors, states ...")
    ## Counts ##
    result$bincounts <- binned.data
    result$bincounts$state <- NULL
    
    ## Bin coordinates, posteriors and states ##
    result$bins <- stepbins
    if (!is.null(use.states$state)) {
        state.levels <- levels(use.states$state)
    } else {
        state.levels <- comb.states
    }
    result$bins$state <- factor(states.step, levels=state.levels)
    stopTimedMessage(ptm)
    
    if (keep.densities) {
        result$bincounts$densities <- densities
    }
    
    ## Add combinations ##
    ptm <- startTimedMessage("Adding combinations ...")
    if (!is.null(use.states)) {
        result$bins$combination <- factor(mapping[as.character(result$bins$state)], levels=levels(use.states$combination))
    } else {
        result$bins$combination <- result$bins$state
    }
    stopTimedMessage(ptm)
    
    ## Segmentation ##
    result$segments <- multivariateSegmentation(result$bins, column2collapseBy='state')
    ptm <- startTimedMessage("Adding differential score ...")
    result$segments$differential.score <- differentialScoreSum(result$segments$maxPostInPeak, result$info)
    stopTimedMessage(ptm)
    if (!keep.posteriors) {
        result$bins$posteriors <- NULL
    }
    if (get.posteriors) {
        ptm <- startTimedMessage("Getting maximum posterior in peaks ...")
        ind <- findOverlaps(result$bins, result$segments)
        result$bins$maxPostInPeak <- result$segments$maxPostInPeak[subjectHits(ind), , drop=FALSE]
        result$bins$differential.score <- result$segments$differential.score[subjectHits(ind)]
        stopTimedMessage(ptm)
            
        ## Peaks ##
        ptm <- startTimedMessage("Obtaining peaks ...")
        result$peaks <- list()
        for (i1 in 1:ncol(result$segments$maxPostInPeak)) {
            mask <- result$segments$maxPostInPeak[,i1] > 0
            peaks <- result$segments[mask]
            mcols(peaks) <- NULL
            peaks$maxPostInPeak <- result$segments$maxPostInPeak[mask,i1]
            result$peaks[[i1]] <- peaks
        }
        names(result$peaks) <- colnames(result$segments$maxPostInPeak)
        stopTimedMessage(ptm)
    }
        
    return(result)

}


#' @importFrom stats pnbinom qnorm dnbinom
prepareInfluence = function(hmms, chromosomes=NULL) {

    nummod <- length(hmms)
    if (nummod > 53) {
        stop("We can't handle more than 53 'hmms' Please decrease the number of input 'hmms'.")
    }

    ## Load first HMM for coordinates
    ptm <- startTimedMessage("Getting coordinates ...")
    hmm <- suppressMessages( loadHmmsFromFiles(hmms[[1]], check.class=class.univariate.hmm)[[1]] )
  # hmm$bins$counts <- array(hmm$bins$counts, dim=c(length(hmm$bins), 1), dimnames=list(bin=NULL, offset='0'))
  # hmm$bincounts <- hmm$bins
  # hmm$bins$counts.rpkm <- rpkm.matrix(hmm$bins$counts, width(hmm$bins)[1])
    bincounts <- hmm$bincounts
    mcols(bincounts) <- NULL
    bins <- hmm$bins
    mcols(bins) <- NULL
    stopTimedMessage(ptm)

    if (!is.null(chromosomes)) {
        chromsNotInData <- setdiff(chromosomes, unique(seqnames(bincounts)))
        if (length(chromsNotInData) == length(chromosomes)) {
            stop("None of the specified chromosomes '", paste0(chromsNotInData, collapse=', '), "' exists.")
        }
        if (length(chromsNotInData)>0) {
            warning("Chromosomes '", paste0(chromsNotInData, collapse=', '), "' could not be found.")
        }
    }

    ## Go through HMMs and extract stuff
    ptm <- startTimedMessage("Extracting read counts ...")
    info <- list(hmm$info)
    distributions <- list(hmm$distributions)
    weights <- list(hmm$weights)
    offsets <- dimnames(hmm$bincounts$counts)[[2]]
    counts <- array(NA, dim = c(length(bincounts), nummod, length(offsets)), dimnames = list(bin=NULL, track=NULL, offset=offsets))
    counts[,1,] <- hmm$bincounts$counts
    counts.rpkm <- array(NA, dim = c(length(hmm$bins), nummod), dimnames = list(bin=NULL, track=NULL))
    counts.rpkm[,1] <- hmm$bins$counts.rpkm
    binary_statesmatrix <- matrix(NA, ncol=nummod, nrow=length(bincounts))
    bins.state <- hmm$bins$state[seq(from=1, to=length(hmm$bins), by=length(hmm$bins)/length(hmm$bincounts))]
    binary_statesmatrix[,1] <- c(FALSE,FALSE,TRUE)[bins.state]
    if (nummod > 1) {
        for (i1 in 2:nummod) {
            hmm <- suppressMessages( loadHmmsFromFiles(hmms[[i1]], check.class=class.univariate.hmm)[[1]] )
        # hmm$bins$counts <- array(hmm$bins$counts, dim=c(length(hmm$bins), 1), dimnames=list(bin=NULL, offset='0'))
        # hmm$bincounts <- hmm$bins
        # hmm$bins$counts.rpkm <- rpkm.matrix(hmm$bins$counts, width(hmm$bins)[1])
            info[[i1]] <- hmm$info
            distributions[[i1]] <- hmm$distributions
            weights[[i1]] <- hmm$weights
            counts[,i1,] <- hmm$bincounts$counts
            counts.rpkm[,i1] <- hmm$bins$counts.rpkm
            bins.state <- hmm$bins$state[seq(from=1, to=length(hmm$bins), by=length(hmm$bins)/length(hmm$bincounts))]
            binary_statesmatrix[,i1] <- c(FALSE,FALSE,TRUE)[bins.state] # F,F,T corresponds to levels 'zero-inflation','unmodified','modified'
        }
    }
    info <- do.call(rbind, info)
    rownames(info) <- NULL
    if (is.null(info)) {
        n <- nummod
        info <- data.frame(file=rep(NA, n), mark=1:n, condition=1:n, replicate=rep(1, n), pairedEndReads=rep(NA, n), controlFiles=rep(NA, n))
        info$ID <- paste0(info$mark, '-', info$condition, '-rep', info$replicate)
    }
    bincounts$counts <- counts
    colnames(bincounts$counts) <- info$ID
    bins$counts.rpkm <- counts.rpkm
    colnames(bins$counts.rpkm) <- info$ID
    maxcounts <- max(bincounts$counts)
    bincounts$binary_statesmatrix <- binary_statesmatrix
    if (!is.null(chromosomes)) {
        # Select only specified chromosomes
        bincounts <- bincounts[seqnames(bincounts) %in% chromosomes]
    }
    stopTimedMessage(ptm)

    # Clean up to reduce memory usage
    remove(hmm)

    ## Transform binary to decimal
    ptm <- startTimedMessage("Getting combinatorial states ...")
    decimal_states <- rep(0,length(bincounts))
    for (imod in 1:nummod) {
        decimal_states <- decimal_states + 2^(nummod-imod) * bincounts$binary_statesmatrix[,imod]
    }
    bincounts$binary_statesmatrix <- NULL
    bincounts$state <- decimal_states
    use.states <- stateBrewer(experiment.table = info[, setdiff(names(info), 'ID'), drop=FALSE], mode = 'all')
    if (is.null(use.states)) {
        comb.states.table <- sort(table(bincounts$state), decreasing=TRUE)
        comb.states <- names(comb.states.table)
    } else {
        comb.states.table <- sort(table(bincounts$state)[as.character(use.states$state)], decreasing=TRUE)
        comb.states <- names(comb.states.table)
        comb.states <- c(comb.states, setdiff(use.states$state, comb.states))
    }
    # Subselect states
    numstates2use <- length(comb.states)
    comb.states <- comb.states[1:numstates2use]
    stopTimedMessage(ptm)

    # Return parameters
    out = list(info = info,
                bincounts = bincounts,
                bins = bins,
                comb.states = comb.states,
                use.states = use.states,
                distributions = distributions,
                weights = weights
    )
    return(out)
}


### Get real transition probabilities ###
transProbs <- function(model) {
    bins <- model$bins
    df <- data.frame(from = bins$combination[-length(bins)], to = bins$combination[-1])
    t <- table(df)
    t <- t[rownames(model$transitionProbs), colnames(model$transitionProbs)]
    t <- sweep(t, MARGIN = 1, STATS = rowSums(t), FUN = '/')
    return(t)
}
