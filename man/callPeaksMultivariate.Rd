% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/callPeaksMultivariate.R
\name{callPeaksMultivariate}
\alias{callPeaksMultivariate}
\title{Fit a Hidden Markov Model to multiple ChIP-seq samples}
\usage{
callPeaksMultivariate(hmms, use.states, max.states = NULL, per.chrom = TRUE,
  chromosomes = NULL, eps = 0.01, post.cutoff = NULL,
  keep.posteriors = TRUE, num.threads = 1, max.time = NULL,
  max.iter = NULL, keep.densities = FALSE, verbosity = 1)
}
\arguments{
\item{hmms}{A list of \code{\link{uniHMM}}s generated by \code{\link{callPeaksUnivariate}}, e.g. \code{list(hmm1,hmm2,...)} or \code{c("file1","file2",...)}.}

\item{use.states}{A data.frame with combinatorial states which are used in the multivariate HMM, generated by function \code{\link{stateBrewer}}. If both \code{use.states} and \code{max.states} are \code{NULL}, the maximum possible number of combinatorial states will be used.}

\item{max.states}{Maximum number of combinatorial states to use in the multivariate HMM. The states are ordered by occurrence as determined from the combination of univariate state calls.}

\item{per.chrom}{If \code{per.chrom=TRUE} chromosomes will be treated separately. This tremendously speeds up the calculation but results might be noisier as compared to \code{per.chrom=FALSE}, where all chromosomes are concatenated for the HMM.}

\item{chromosomes}{A vector specifying the chromosomes to use from the models in \code{hmms}. The default (\code{NULL}) uses all available chromosomes.}

\item{eps}{Convergence threshold for the Baum-Welch algorithm.}

\item{post.cutoff}{False discovery rate. The default \code{NULL} means that the state with maximum posterior probability will be chosen, irrespective of its absolute probability.}

\item{keep.posteriors}{If set to \code{TRUE}, posteriors will be available in the output. This is useful to change the post.cutoff later, but increases the necessary disk space to store the result immense.}

\item{num.threads}{Number of threads to use. Setting this to >1 may give increased performance.}

\item{max.time}{The maximum running time in seconds for the Baum-Welch algorithm. If this time is reached, the Baum-Welch will terminate after the current iteration finishes. The default \code{NULL} is no limit.}

\item{max.iter}{The maximum number of iterations for the Baum-Welch algorithm. The default \code{NULL} is no limit.}

\item{keep.densities}{If set to \code{TRUE} (default=\code{FALSE}), densities will be available in the output. This should only be needed debugging.}

\item{verbosity}{Verbosity level for the fitting procedure. 0 - No output, 1 - Iterations are printed.}
}
\value{
A \code{\link{multiHMM}} object.
}
\description{
Fit a HMM to multiple ChIP-seq samples to determine the combinatorial state of genomic regions. Input is a list of \code{\link{uniHMM}}s generated by \code{\link{callPeaksUnivariate}}.
}
\details{
Emission distributions from the univariate HMMs are used with a Gaussian copula to generate a multivariate emission distribution for each combinatorial state. This multivariate distribution is then kept fixed and the transition probabilities are fitted with a Baum-Welch. See our paper TODO:insert paper for details.
}
\examples{
# Get example BED files for 2 different marks in hypertensive rat
file.path <- system.file("extdata","euratrans", package='chromstaRData')
bedfiles <- list.files(file.path, full.names=TRUE, pattern='SHR')[c(1:2,6:7)]
# Construct experiment structure
exp <- data.frame(file=bedfiles, mark=c("H3K27me3","H3K27me3","H3K4me3","H3K4me3"),
                 condition=rep("SHR",4), replicate=c(1:2,1:2), pairedEndReads=FALSE)
states <- stateBrewer(exp, mode='mark')
# Bin the data
data(rn4_chrominfo)
binned.data <- list()
for (bedfile in bedfiles) {
 binned.data[[basename(bedfile)]] <- binReads(bedfile, binsize=1000, experiment.table=exp,
                                              assembly=rn4_chrominfo, chromosomes='chr12')
}
# Obtain the univariate fits
models <- list()
for (i1 in 1:length(binned.data)) {
 models[[i1]] <- callPeaksUnivariate(binned.data[[i1]], max.time=60, eps=1)
}
# Call multivariate peaks
multimodel <- callPeaksMultivariate(models, use.states=states, eps=1, max.time=60)
# Check some plots
plot(multimodel, type='transitionMatrix')
plot(multimodel, type='correlation')

}
\author{
Aaron Taudt, Maria Colome Tatche
}
\seealso{
\code{\link{multiHMM}}, \code{\link{callPeaksUnivariate}}, \code{\link{callPeaksReplicates}}
}

