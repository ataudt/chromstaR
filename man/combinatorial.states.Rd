\name{combinatorial.states}
\alias{combinatorial.states}
\title{
Get the (decimal) combinatorial states of a list of HMM models
}
\description{
Get the combinatorial states of a list of models generated by \code{\link{univariate.from.binned.data}}. The function returns the decimal combinatorial states for each bin (see details for an explanation of combinatorial state).
}
\usage{
combinatorial.states(modellist, threshold=0.5)
}
\arguments{
\item{modellist}{
A list of models generated by \code{\link{univariate.from.binned.data}}, e.g. 'list(model1,model2,...)'.
}
\item{threshold}{
Threshold for calling a bin modified or unmodified. If the posterior for state 'modified' is greater than the threshold, then this bin will be called modified.
}
}

\details{
For a given model, each genomic bin can be either called unmodified (0) or modified (1), depending on how the posterior probabilities were estimated by the Baum-Welch. Thus, a list of models defines a binary combinatorial state for each bin. This binary combinatorial state can be expressed as a decimal number.

Example: We have 4 histone modifications, and we run the univariate HMM for each of them. Then we use a threshold of 0.5 to call each bin either unmodified (0) or modified (1). The resulting binary combinatorial states can then be converted to decimal representation. The following table illustrates this:

\tabular{crrrrr}{
bin \tab modification state \tab \tab \tab \tab decimal state\cr
    \tab model1 \tab model2 \tab model3 \tab model4 \tab     \cr
1   \tab      0 \tab      0 \tab      1 \tab      0 \tab 2   \cr
2   \tab      0 \tab      0 \tab      0 \tab      0 \tab 0   \cr
3   \tab      0 \tab      1 \tab      1 \tab      0 \tab 6   \cr
4   \tab      0 \tab      1 \tab      1 \tab      1 \tab 7   \cr
}
}
\value{
Output is a vector of integers representing the combinatorial state of each bin.
}
\keyword{combinatorial}
\keyword{decimal}
\keyword{binary}
\references{}
\author{Aaron Taudt}
\note{}
\seealso{}
\examples{
# Load example datasets and do univariate HMMs
data(binned.data.example.1)
data(binned.data.example.2)
model1 = univariate.from.binned.data(binned.data.example.1, eps=1, max.time=60)
model2 = univariate.from.binned.data(binned.data.example.2, eps=1, max.time=60)
# We have 2 models and therefore 4 possible combinatorial states (0,1,2,3)
combstates = combinatorial.states(list(model1,model2))
# Have a look at the output
temp = cbind(model1$coordinates,combstates)
head(temp,20)
}
