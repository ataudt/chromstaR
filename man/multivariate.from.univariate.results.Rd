\name{multivariate.from.univariate.results}
\alias{multivariate.from.univariate.results}
\title{
Perform the multivariate HMM with univariate results
}
\description{
Use univariate models generated by \code{\link{univariate.from.binned.data}} to estimate a multivariate Hidden Markov Model (HMM).
}
\usage{
multivariate.from.univariate.results(modellist, use.states=NULL, num.states=NULL, eps=0.001, num.threads=2, max.time=-1, max.it=-1, output.if.not.converged=FALSE)
}
\arguments{
\item{modellist}{
A list of models generated by \code{\link{univariate.from.binned.data}}, e.g. 'list(model1,model2,...)'.
}
\item{use.states}{
A vector of combinatorial states which are used in the multivariate HMM. If specified, option 'num.states' will be ignored. If it is not possible to use the specified 'states', e.g. because their occurrence in the genome is too low, an error will be thrown.
} 
\item{num.states}{
Number of states (ordered by occurrence) to use in the multivariate HMM. This number will be used unless it is not possible to do so, e.g. because the total number of combinatorial states is lower or because the inverse of the correlation matrix would be singular for some states. A warning is issued in these cases and the maximum possible number of states is used instead.
}
\item{eps}{
Convergence threshold for the Baum-Welch algorithm.
}
\item{num.threads}{
The number of threads to use for the computations. The default of 2 threads yields the best performance for a moderate number of states. Only set to higher numbers for high numbers of states (num.states > 80).
}
\item{max.time}{
The maximum running time for the Baum-Welch algorithm. If this time is reached, the Baum-Welch will terminate after the current iteration finishes. Negative numbers are interpreted as no limit.
}
\item{max.it}{
The maximum number of iterations for the Baum-Welch algorithm. Negative numbers are interpreted as no limit.
}
\item{output.if.not.converged}{
If set to 'FALSE', no output will be given in the case that the Baum-Welch did not converge to the desired 'eps'. If set to 'TRUE', a model will be returned even if the Baum-Welch did not converge to the desired 'eps'.
}
}

\details{
The function expects a list of models, which were generated by the function \code{\link{univariate.from.binned.data}}. The output will again be a model, which contains the posteriors of the Baum-Welch likelihood maximization and various other variables. All attributes can be accessed with the '$' or '[[ ]]' operator. To see which attributes are available, type "names(output)" (without quotation marks).
}
\value{
The output is a list object with various entries:
\item{coordinates}{A data.frame with genomic coordinates. These are the same as in the input.}
\item{reads}{A matrix containing the reads from the input models.}
\item{posteriors}{Posterior probabilities of the Baum-Welch estimation.}
\item{loglik}{Logarithm of the likelihood estimator (goodness of the fit).}
\item{iteration}{Number of iterations performed by the Baum-Welch.}
\item{time.in.sec}{Time in seconds spent in the Baum-Welch.}
\item{delta.loglik}{Change of the log(likelihood) in the last step. This should be smaller than the 'epsilon' in case of convergence.}
\item{epsilon}{Convergence threshold used for the Baum-Welch.}
\item{proba}{Estimated posteriors of the first bin.}
\item{A}{Estimated transition matrix.}
\item{proba.initial}{Initial probabilities of the first bin.}
\item{A.initial}{Initial transition matrix.}
\item{stateorder}{Combinatorial states ordered by frequency.}
\item{num.threads}{Number of threads used for the computations.}
}
\keyword{Hidden Markov Model}
\keyword{Baum-Welch}
\keyword{multivariate}
\references{}
\author{Maria Colome Tatche and Aaron Taudt}
\note{}
\seealso{}
\examples{
# Load example datasets with genome coordinates and number of aligned reads for each bin
data(binned.data.example.1)
data(binned.data.example.2)
# Do the univariate HMMs
model1 = univariate.from.binned.data(binned.data.example.1, eps=1, max.time=60)
model2 = univariate.from.binned.data(binned.data.example.2, eps=1, max.time=60)
# Do the multivariate HMM
multimodel = multivariate.from.univariate.results(list(model1,model2), eps=1, max.time=180)
# Look at the output
names(multimodel)
# Select the posteriors
head(multimodel$posteriors)
}
