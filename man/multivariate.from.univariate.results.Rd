\name{multivariate.from.univariate.results}
\alias{multivariate.from.univariate.results}
\title{
Run an HMM for multiple histone marks
}
\description{
Run an HMM for multiple histone marks to determine the combinatorial state of genomic regions. Input is a \code{\link{chromstar.univariate.hmm}} generated by \code{\link{univariate.from.binned.data}}.
}
\usage{
multivariate.from.univariate.results(modellist, use.states=NULL, num.states=NULL, eps=0.001, num.threads=1, max.time=-1, max.iter=-1, output.if.not.converged=FALSE, use.total.correlation=FALSE, checkpoint.after.iter=-1, checkpoint.after.time=-1, checkpoint.file="chromStar_checkpoint", checkpoint.reduce=c("coordinates","reads","posteriors"), checkpoint.overwrite=TRUE, checkpoint.use.existing=FALSE, A.initial=NULL)
}
\arguments{
\item{modellist}{
A list of \code{\link{chromstar.univariate.hmm}}s generated by \code{\link{univariate.from.binned.data}}, e.g. \option{list(hmm1,hmm2,...)} or \option{c("file1","file2",...)}.
}
\item{use.states}{
A vector of combinatorial states which are used in the multivariate HMM. If specified, option \option{num.states} will be ignored. An error is thrown if the specified states cannot be used (either because they do not exist or their occurrence in the genome is too low).
} 
\item{num.states}{
Number of combinatorial states to use in the multivariate HMM. The states are ordered by occurrence as determined from the combination of univariate state calls. If it is not possible to use the specified number of states - e.g. because the total number of combinatorial states is lower or because the inverse of the correlation matrix would be singular for some states - a warning is issued and the maximum possible number of states is used instead.
}
\item{eps}{Convergence threshold for the Baum-Welch algorithm.}
\item{num.threads}{Number of threads to use. Setting this to >1 may give increased performance.}
\item{max.time}{The maximum running time for the Baum-Welch algorithm. If this time is reached, the Baum-Welch will terminate after the current iteration finishes. The default -1 is no limit.}
\item{max.iter}{The maximum number of iterations for the Baum-Welch algorithm. The default -1 is no limit.}
\item{output.if.not.converged}{
If set to FALSE, no output will be given in the case that the Baum-Welch did not converge to the desired \option{eps}. If set to TRUE, a model will be returned even if the Baum-Welch did not converge to the desired \option{eps}.
}
\item{use.total.correlation}{Calculate only one correlation matrix for all states instead of individual correlation matrices (TODO: remove because obsolete).}
\item{checkpoint.after.iter}{Write a checkpoint file every n iterations. The default -1 means no checkpointing for iterations.}
\item{checkpoint.after.time}{Write a checkpoint file every t seconds. The default -1 means no checkpointing for time.}
\item{checkpoint.file}{The name of the checkpoint file that will be written.}
\item{checkpoint.reduce}{
A vector of strings that correspond to entries in the \code{\link{chromstar.multivariate.hmm}} output object. The specified entries will be removed from the checkpoints to save disk space. By default, c("coordinates","reads","posteriors") are removed.
}
\item{checkpoint.overwrite}{
If set to TRUE, only one checkpoint file will be written. If set to FALSE, a new checkpoint file will be written at each checkpoint with the total number of iterations appended.
}
\item{checkpoint.use.existing}{If set to TRUE, the calculation will be continued from the HMM in the \option{checkpoint.file}.}
\item{A.initial}{The only option is "estimate". If this option is set, an initial transition matrix will be computed from the combinatorial states that result from the combination of univariate states.}
}

\details{

}
\value{
The output is a \code{\link{chromstar.multivariate.hmm}} list object.
}

\keyword{Hidden Markov Model}
\keyword{Baum-Welch}
\keyword{multivariate}
\references{}
\author{Maria Colome Tatche and Aaron Taudt}
\note{}
\seealso{}
\examples{
# TODO: change this
# Load example datasets with genome coordinates and number of aligned reads for each bin
data(binned.data.example.1)
data(binned.data.example.2)
# Do the univariate HMMs
model1 = univariate.from.binned.data(binned.data.example.1, eps=1, max.time=60)
model2 = univariate.from.binned.data(binned.data.example.2, eps=1, max.time=60)
# Do the multivariate HMM
multimodel = multivariate.from.univariate.results(list(model1,model2), eps=1, max.time=180)
# Look at the output
names(multimodel)
# Select the posteriors
head(multimodel$posteriors)
}
